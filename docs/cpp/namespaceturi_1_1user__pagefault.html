<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::user_pagefault Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceturi_1_1user__pagefault.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">turi::user_pagefault Namespace Reference<div class="ingroups"><a class="el" href="group__pagefault.html">User Mode Page Fault Handler</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2ee4922115ac4c9ac1e8f7ac5140961"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; size_t(<a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a> *pageset, char *address, size_t fill_length)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#ab2ee4922115ac4c9ac1e8f7ac5140961">userpf_handler_callback</a></td></tr>
<tr class="separator:ab2ee4922115ac4c9ac1e8f7ac5140961"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6507a17bd6d085639719511b3f7e9e62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a6507a17bd6d085639719511b3f7e9e62">setup_pagefault_handler</a> (size_t max_resident_memory=(size_t)(-1))</td></tr>
<tr class="separator:a6507a17bd6d085639719511b3f7e9e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8216b89f8e327bdef14b005a3d4e06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#afb8216b89f8e327bdef14b005a3d4e06">is_pagefault_handler_installed</a> ()</td></tr>
<tr class="separator:afb8216b89f8e327bdef14b005a3d4e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58332405a1897dacf23db257d4741e12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a58332405a1897dacf23db257d4741e12">get_max_resident</a> ()</td></tr>
<tr class="separator:a58332405a1897dacf23db257d4741e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6075c627c6b047364872f3f81970b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#ad6075c627c6b047364872f3f81970b19">set_max_resident</a> (size_t max_resident_memory)</td></tr>
<tr class="separator:ad6075c627c6b047364872f3f81970b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c7950ab1b065bc4c9d53f4723cfaf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a98c7950ab1b065bc4c9d53f4723cfaf0">allocate</a> (size_t length, <a class="el" href="namespaceturi_1_1user__pagefault.html#ab2ee4922115ac4c9ac1e8f7ac5140961">userpf_handler_callback</a> fill_callback, userpf_release_callback release_callback=nullptr, bool writable=true)</td></tr>
<tr class="separator:a98c7950ab1b065bc4c9d53f4723cfaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53cb0dc3d49ccc77afc4859417a657d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#ac53cb0dc3d49ccc77afc4859417a657d">release</a> (<a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a> *pageset)</td></tr>
<tr class="separator:ac53cb0dc3d49ccc77afc4859417a657d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74235e9957826631829938e202cb3a2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a74235e9957826631829938e202cb3a2f">revert_pagefault_handler</a> ()</td></tr>
<tr class="separator:a74235e9957826631829938e202cb3a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc574627e7317bc59f52cf2d1996f17"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a1bc574627e7317bc59f52cf2d1996f17">get_num_allocations</a> ()</td></tr>
<tr class="separator:a1bc574627e7317bc59f52cf2d1996f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1222192dd0ed13c864e3777b2d43d6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#aea1222192dd0ed13c864e3777b2d43d6">pagefile_total_allocated_bytes</a> ()</td></tr>
<tr class="separator:aea1222192dd0ed13c864e3777b2d43d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36961eb3e9422b6dcab15ef12fe08d77"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a36961eb3e9422b6dcab15ef12fe08d77">pagefile_total_stored_bytes</a> ()</td></tr>
<tr class="separator:a36961eb3e9422b6dcab15ef12fe08d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81da2c6a583e0e4e78f0f1292eb52a49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#a81da2c6a583e0e4e78f0f1292eb52a49">pagefile_compression_ratio</a> ()</td></tr>
<tr class="separator:a81da2c6a583e0e4e78f0f1292eb52a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aff602c86f17f180153ba65a963840428"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1user__pagefault.html#aff602c86f17f180153ba65a963840428">TURI_PAGE_SIZE</a></td></tr>
<tr class="separator:aff602c86f17f180153ba65a963840428"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This implements a user mode page fault handler.</p>
<p>The basic mechanics of operation are not very complicated. We first install a segfault_handler.</p>
<p>When you ask for some memory, we use mmap to allocate a region, but set memory protection on it to PROT_NONE (disable both read and writes to the region). This way, every memory access to the region will trigger a segfault.</p>
<p>When the memory is accessed, the segfault handler (segv_handler()) is triggered, and try to fill in the data in the page. To do so, (fill_pages()) we set the protection on the page to PROT_READ | PROT_WRITE (enable read + write), call a callback function to fill in the data, then sets the protection on the page to PROT_READ. Then we return from the segfault handler which allows the program to resume execution correctly (but cannot write to the memory, only read).</p>
<p>We keep a queue of pages we have committed (add_to_access_queue()). and when the queue size becomes too large, we start evicting/decommitting pages (handle_eviction()). Essentially we are doing FIFO caching. To "evict" a set of pages simply involves calling madvise(MADV_DONTNEED) on the pages.</p>
<p>A bunch of additional maintenance stuff are needed:</p><ul>
<li>a queue of committed pages (used to manage eviction)</li>
<li>The set of all regions (page_sets) allocated, sorted by address to permit fast binary searches). this is used to figure out the mapping between address and callback.</li>
</ul>
<p>One key design consideration is the careful use of mmap. The way the procedure is defined above only calls mmap once for the entire region. decommitting and committing memory is done by use of memory protection and madvise. Alternate implementation built entirely around mmap is possible where we use completely unallocated memory addresses, and use mmap to map the pages in as required. But this requires a large number of calls to mmap, which uses up a lot of kernel datastructures, which will cause mmap to fail with ENOMEM after a while.</p>
<p>Also, with regards to parallelism, the kernel API does not quite provide sufficient capability to handle parallel accesses correctly. What is missing is an atomic "fill and enable page read/write" function. Essentially, while the callback function is filling in the pages for a particular memory address, some other thread can read from the same memory addresses and get erroneous values. mremap could in theory be used to enable this by having the callback fill to alternate pages, and using mremap to atomically swap those pages in. However, see the design consideration above regarding excessive use of mmap. Also, mremap is not available on OS X. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab2ee4922115ac4c9ac1e8f7ac5140961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;size_t (<a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a>* pageset, char* address, size_t fill_length)&gt; <a class="el" href="namespaceturi_1_1user__pagefault.html#ab2ee4922115ac4c9ac1e8f7ac5140961">turi::user_pagefault::userpf_handler_callback</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Page filling callback </p>

<p>Definition at line <a class="el" href="user__pagefault_8hpp_source.html#l00074">74</a> of file <a class="el" href="user__pagefault_8hpp_source.html">user_pagefault.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a98c7950ab1b065bc4c9d53f4723cfaf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a>* turi::user_pagefault::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi_1_1user__pagefault.html#ab2ee4922115ac4c9ac1e8f7ac5140961">userpf_handler_callback</a>&#160;</td>
          <td class="paramname"><em>fill_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">userpf_release_callback&#160;</td>
          <td class="paramname"><em>release_callback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a block of memory of a certain length, where the contents of the memory are to be filled using the specified callback function.</p>
<p>Returns a page_set pointer where page_set-&gt;begin is the memory address at which on-demand paging will be performed. The callback is triggered to fill in the pages on demand.</p>
<p>The pagefault handler is an std::function object of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> fill_callback(userpf_page_set* ps,</div><div class="line">                     <span class="keywordtype">char</span>* address, </div><div class="line">                     <span class="keywordtype">size_t</span> fill_length) {</div><div class="line">  <span class="comment">// MUST fill in the contents of address to address + fill_length</span></div><div class="line">  <span class="comment">// most not write out of the bounds of [address, address+fill_length)</span></div><div class="line">  <span class="comment">// for instance, to fill in the array such that</span></div><div class="line">  <span class="comment">// arr = (size_t*)(ps-&gt;begin)</span></div><div class="line">  <span class="comment">// arr[i] == i</span></div><div class="line">  <span class="comment">// we do the following:</span></div><div class="line"></div><div class="line">   <span class="keywordtype">size_t</span>* root = (<span class="keywordtype">size_t</span>*) ps-&gt;begin;</div><div class="line">   <span class="keywordtype">size_t</span>* s_addr  = (<span class="keywordtype">size_t</span>*) page_address;</div><div class="line"></div><div class="line">   <span class="keywordtype">size_t</span> begin_value = s_addr - root;</div><div class="line">   <span class="keywordtype">size_t</span> num_to_fill = minimum_fill_length / <span class="keyword">sizeof</span>(size_t);</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_to_fill; ++i) {</div><div class="line">     s_addr[i] = i + begin_value;</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The release_callback is an std::function object of the form: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> release_callback(userpf_page_set* ps) {</div><div class="line">  <span class="comment">// for instance, we may write out the contents of </span></div><div class="line">  <span class="comment">// ps-&gt;begin to ps-&gt;end to disk here.</span></div><div class="line">}</div></div><!-- fragment --><p> The release_callback function <em>must</em> be reentrant with the fill_callback function. This is because memory accesses performed by release_callback into to the pointer may trigger the fill_callback to fill in the memory regions.</p>
<p>If writable is set (default false), the <a class="el" href="namespaceturi_1_1user__pagefault.html">user_pagefault</a> handler will perform automatic read/write/eviction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The number of bytes to allocate </td></tr>
    <tr><td class="paramname">fill_callback</td><td>The callback to be triggered when a page range needs to be filled. </td></tr>
    <tr><td class="paramname">release_callback</td><td>The callback to be triggered the the memory is released, i.e. release(pf) is called. </td></tr>
    <tr><td class="paramname">writable</td><td>If the page range is to be writable. The pagefault handler will handle paging. The returned object MUST NOT be freed or deallocated. use <a class="el" href="namespaceturi_1_1user__pagefault.html#ac53cb0dc3d49ccc77afc4859417a657d">release</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58332405a1897dacf23db257d4741e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::user_pagefault::get_max_resident </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum amount of resident memory to be used before memory is decommitted. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceturi_1_1user__pagefault.html#a6507a17bd6d085639719511b3f7e9e62">setup_pagefault_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bc574627e7317bc59f52cf2d1996f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::user_pagefault::get_num_allocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of allocations made </p>

</div>
</div>
<a class="anchor" id="afb8216b89f8e327bdef14b005a3d4e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::user_pagefault::is_pagefault_handler_installed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the pagefault handler is installed </p>

</div>
</div>
<a class="anchor" id="a81da2c6a583e0e4e78f0f1292eb52a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double turi::user_pagefault::pagefile_compression_ratio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of bytes stored compressed. </p>

</div>
</div>
<a class="anchor" id="aea1222192dd0ed13c864e3777b2d43d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::user_pagefault::pagefile_total_allocated_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retursn the total number of bytes allocated to the pagefile </p>

</div>
</div>
<a class="anchor" id="a36961eb3e9422b6dcab15ef12fe08d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::user_pagefault::pagefile_total_stored_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of bytes actually stored in the pagefile (after compression and stuff) </p>

</div>
</div>
<a class="anchor" id="ac53cb0dc3d49ccc77afc4859417a657d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::user_pagefault::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structturi_1_1user__pagefault_1_1userpf__page__set.html">userpf_page_set</a> *&#160;</td>
          <td class="paramname"><em>pageset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the pageset. The caller must ensure that there are no other memory accesses for this allocation. </p>

</div>
</div>
<a class="anchor" id="a74235e9957826631829938e202cb3a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::user_pagefault::revert_pagefault_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the on-demand paging handlers.</p>
<p>Releases the pagefault handler, reverting it to the previous handler if any. Returns true if the pagefault handler was disabled successfully, false otherwise. </p>

</div>
</div>
<a class="anchor" id="ad6075c627c6b047364872f3f81970b19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::user_pagefault::set_max_resident </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_resident_memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum amount of resident memory to be used before memory is decommitted. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceturi_1_1user__pagefault.html#a6507a17bd6d085639719511b3f7e9e62">setup_pagefault_handler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6507a17bd6d085639719511b3f7e9e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::user_pagefault::setup_pagefault_handler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_resident_memory</em> = <code>(size_t)(-1)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the on-demand paging handlers.</p>
<p>max_resident_memory The maximum amount of resident memory to be used before memory is decommited. If not provided (-1), the environment variable TURI_DEFAULT_PAGEFAULT_RESIDENT_LIMIT is read. If not available a default value corresponding to half of total memory size is used.</p>
<p>Returns true if the pagefault handler was installed successfully, and false otherwise. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aff602c86f17f180153ba65a963840428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::user_pagefault::TURI_PAGE_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The page size we operate at. see user_pagefault.cpp for the actual value. generally, we want to avoid working at the granularity of single system pages. While that is going to be faster for random access, that will trigger a very large number of segfaults and will also require quite a lot of kernel datastructures. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="namespaceturi_1_1user__pagefault.html">user_pagefault</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
