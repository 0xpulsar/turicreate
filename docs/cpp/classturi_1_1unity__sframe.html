<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::unity_sframe Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1unity__sframe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1unity__sframe-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::unity_sframe Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="unity__sframe_8hpp_source.html">unity/lib/unity_sframe.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf1a6f5e8d3102e6d03154d1627f0b69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#acf1a6f5e8d3102e6d03154d1627f0b69">unity_sframe</a> ()</td></tr>
<tr class="separator:acf1a6f5e8d3102e6d03154d1627f0b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64182cf0b9259ca8d1a1f9dbad021843"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a64182cf0b9259ca8d1a1f9dbad021843">~unity_sframe</a> ()</td></tr>
<tr class="separator:a64182cf0b9259ca8d1a1f9dbad021843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8daf1dcf1f1a5c9ce3f3f90daa4c10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#abf8daf1dcf1f1a5c9ce3f3f90daa4c10">construct_from_dataframe</a> (const <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> &amp;df)</td></tr>
<tr class="separator:abf8daf1dcf1f1a5c9ce3f3f90daa4c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36535542e68005db87cbc35860ee7f7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a36535542e68005db87cbc35860ee7f7b">construct_from_sframe</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf)</td></tr>
<tr class="separator:a36535542e68005db87cbc35860ee7f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f8644a8c177be7de2a0710b209f4e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ae9f8644a8c177be7de2a0710b209f4e9">construct_from_sframe_index</a> (std::string index_file)</td></tr>
<tr class="separator:ae9f8644a8c177be7de2a0710b209f4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26fb4e5ca6342cc28a417c12e18b78a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::shared_ptr&lt; unity_sarray_base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ac26fb4e5ca6342cc28a417c12e18b78a">construct_from_csvs</a> (std::string url, std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; parsing_config, std::map&lt; std::string, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; column_type_hints)</td></tr>
<tr class="separator:ac26fb4e5ca6342cc28a417c12e18b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d21a776859e3c422b83ebd9d50b77b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a1d21a776859e3c422b83ebd9d50b77b6">save_frame</a> (std::string target_directory)</td></tr>
<tr class="separator:a1d21a776859e3c422b83ebd9d50b77b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f383f45511896dbc7579feb130ba9e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a8f383f45511896dbc7579feb130ba9e1">save_frame_reference</a> (std::string target_directory)</td></tr>
<tr class="separator:a8f383f45511896dbc7579feb130ba9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addea1ba2951b8a8f21c333b4a1430b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#addea1ba2951b8a8f21c333b4a1430b2f">save_frame_by_index_file</a> (std::string index_file)</td></tr>
<tr class="separator:addea1ba2951b8a8f21c333b4a1430b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef08a07f29d2705a06e645b93c11091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a0ef08a07f29d2705a06e645b93c11091">clear</a> ()</td></tr>
<tr class="separator:a0ef08a07f29d2705a06e645b93c11091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849e505ca625f231582a38763be3cc54"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a849e505ca625f231582a38763be3cc54">size</a> ()</td></tr>
<tr class="separator:a849e505ca625f231582a38763be3cc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed12630d98c2825d44ead9218a399e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#aeed12630d98c2825d44ead9218a399e3">num_columns</a> ()</td></tr>
<tr class="separator:aeed12630d98c2825d44ead9218a399e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd3262a93b45910737f785c57d2b5a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a8fd3262a93b45910737f785c57d2b5a3">dtype</a> ()</td></tr>
<tr class="separator:a8fd3262a93b45910737f785c57d2b5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f9de6c5abca26cd9c3de902c956320"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a08f9de6c5abca26cd9c3de902c956320">column_names</a> ()</td></tr>
<tr class="separator:a08f9de6c5abca26cd9c3de902c956320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ecf0228cf3302a21523be2fc727637"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a19ecf0228cf3302a21523be2fc727637">head</a> (size_t nrows)</td></tr>
<tr class="separator:a19ecf0228cf3302a21523be2fc727637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385c28fb2dc312aea7d6327cecda3802"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a385c28fb2dc312aea7d6327cecda3802">column_index</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a385c28fb2dc312aea7d6327cecda3802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfa5e9bf78162b65bb5cefe23f89ffc"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#abbfa5e9bf78162b65bb5cefe23f89ffc">column_name</a> (size_t index)</td></tr>
<tr class="separator:abbfa5e9bf78162b65bb5cefe23f89ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93850223f37ed71ffb1a5b5f14fb9a48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a93850223f37ed71ffb1a5b5f14fb9a48">contains_column</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a93850223f37ed71ffb1a5b5f14fb9a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890a2faaacff42437ba5bb6266f229a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a890a2faaacff42437ba5bb6266f229a2">_head</a> (size_t nrows)</td></tr>
<tr class="separator:a890a2faaacff42437ba5bb6266f229a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e414417d80b5a0b4242f57050314ff"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad2e414417d80b5a0b4242f57050314ff">tail</a> (size_t nrows)</td></tr>
<tr class="separator:ad2e414417d80b5a0b4242f57050314ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad065dfa621df0a88be920bf36f68471d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad065dfa621df0a88be920bf36f68471d">_tail</a> (size_t nrows)</td></tr>
<tr class="separator:ad065dfa621df0a88be920bf36f68471d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1553568db9179d9cea749e9386d45cf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad1553568db9179d9cea749e9386d45cf">select_column</a> (const std::string &amp;name)</td></tr>
<tr class="separator:ad1553568db9179d9cea749e9386d45cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa618b984e2e381286866a34e74884d62"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#aa618b984e2e381286866a34e74884d62">logical_filter</a> (std::shared_ptr&lt; unity_sarray_base &gt; index)</td></tr>
<tr class="separator:aa618b984e2e381286866a34e74884d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b8f7b00d84439fa50c7282aa0e9dd3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ae2b8f7b00d84439fa50c7282aa0e9dd3">select_columns</a> (const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="separator:ae2b8f7b00d84439fa50c7282aa0e9dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf02fd6ca95d55dbbb42028ca543397e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#aaf02fd6ca95d55dbbb42028ca543397e">add_column</a> (std::shared_ptr&lt; unity_sarray_base &gt;data, const std::string &amp;name)</td></tr>
<tr class="separator:aaf02fd6ca95d55dbbb42028ca543397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9cd6cc6f468214ea4fcd602e42acd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#aba9cd6cc6f468214ea4fcd602e42acd6">add_columns</a> (std::list&lt; std::shared_ptr&lt; unity_sarray_base &gt;&gt; data_list, std::vector&lt; std::string &gt; name_vec)</td></tr>
<tr class="separator:aba9cd6cc6f468214ea4fcd602e42acd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5a59c446df522fd6dd6e08dc6079e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a27f5a59c446df522fd6dd6e08dc6079e">transform</a> (const std::string &amp;lambda, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type, bool skip_undefined, int seed)</td></tr>
<tr class="separator:a27f5a59c446df522fd6dd6e08dc6079e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29cf5557069d505f7ec2914a3c09e37"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ac29cf5557069d505f7ec2914a3c09e37">transform_native</a> (const <a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a> &amp;lambda, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type, bool skip_undefined, int seed)</td></tr>
<tr class="separator:ac29cf5557069d505f7ec2914a3c09e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f632b4471babf843ce37c4cf6aae1d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#af9f632b4471babf843ce37c4cf6aae1d">transform_lambda</a> (std::function&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>(const <a class="el" href="structturi_1_1sframe__rows_1_1row.html">sframe_rows::row</a> &amp;)&gt; lambda, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type, int seed)</td></tr>
<tr class="separator:af9f632b4471babf843ce37c4cf6aae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4077dbd7f360570da490f9117f2043a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad4077dbd7f360570da490f9117f2043a">flat_map</a> (const std::string &amp;lambda, std::vector&lt; std::string &gt; output_column_names, std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; output_column_types, bool skip_undefined, int seed)</td></tr>
<tr class="separator:ad4077dbd7f360570da490f9117f2043a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63cf8315424dbef4da3b09a3e1827ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad63cf8315424dbef4da3b09a3e1827ac">set_column_name</a> (size_t i, std::string name)</td></tr>
<tr class="separator:ad63cf8315424dbef4da3b09a3e1827ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99926f25180b64e4edefa764247cb349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a99926f25180b64e4edefa764247cb349">remove_column</a> (size_t i)</td></tr>
<tr class="separator:a99926f25180b64e4edefa764247cb349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc2c9ab6a838167e617db9fda7056c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a0cc2c9ab6a838167e617db9fda7056c4">swap_columns</a> (size_t i, size_t j)</td></tr>
<tr class="separator:a0cc2c9ab6a838167e617db9fda7056c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ad3104a083de00183702ba4eae090b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad1ad3104a083de00183702ba4eae090b">get_underlying_sframe</a> ()</td></tr>
<tr class="separator:ad1ad3104a083de00183702ba4eae090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101e30368649011ff7e73775341edfd6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">query_eval::planner_node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a101e30368649011ff7e73775341edfd6">get_planner_node</a> ()</td></tr>
<tr class="separator:a101e30368649011ff7e73775341edfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f9ec8d04de7d05c5a30b5870ee4dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#af9f9ec8d04de7d05c5a30b5870ee4dd5">set_sframe</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt; &amp;sf_ptr)</td></tr>
<tr class="separator:af9f9ec8d04de7d05c5a30b5870ee4dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e130823dc0fdc11547275b7f713d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a09e130823dc0fdc11547275b7f713d0d">begin_iterator</a> ()</td></tr>
<tr class="separator:a09e130823dc0fdc11547275b7f713d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42ed6176e1674d62db3c536554cfbad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#af42ed6176e1674d62db3c536554cfbad">iterator_get_next</a> (size_t len)</td></tr>
<tr class="separator:af42ed6176e1674d62db3c536554cfbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda760503bd25757ceff82fcd4830b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a1bda760503bd25757ceff82fcd4830b0">save_as_csv</a> (const std::string &amp;url, std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; writing_config)</td></tr>
<tr class="separator:a1bda760503bd25757ceff82fcd4830b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492e7835faf826c5f9b2a3791461046f"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::shared_ptr&lt; unity_sframe_base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a492e7835faf826c5f9b2a3791461046f">random_split</a> (float percent, int random_seed)</td></tr>
<tr class="separator:a492e7835faf826c5f9b2a3791461046f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ca30e0d5c905c0464ad28858acb54"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a9a9ca30e0d5c905c0464ad28858acb54">sample</a> (float percent, int random_seed)</td></tr>
<tr class="separator:a9a9ca30e0d5c905c0464ad28858acb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bed7000cb61f1b872ffec02e0be6aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a67bed7000cb61f1b872ffec02e0be6aa">materialize</a> ()</td></tr>
<tr class="separator:a67bed7000cb61f1b872ffec02e0be6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada83f8f216ee397bca507d237cb66c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#aada83f8f216ee397bca507d237cb66c2">is_materialized</a> ()</td></tr>
<tr class="separator:aada83f8f216ee397bca507d237cb66c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674c877978344bdc5e86377c7cf51f8a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a674c877978344bdc5e86377c7cf51f8a">query_plan_string</a> ()</td></tr>
<tr class="separator:a674c877978344bdc5e86377c7cf51f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4623a0c3398a1303f8774e08d30117ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a4623a0c3398a1303f8774e08d30117ca">has_size</a> ()</td></tr>
<tr class="separator:a4623a0c3398a1303f8774e08d30117ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf17f956c27440e2c6565db68e0b0d9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#acbf17f956c27440e2c6565db68e0b0d9">groupby_aggregate</a> (const std::vector&lt; std::string &gt; &amp;key_columns, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;group_columns, const std::vector&lt; std::string &gt; &amp;group_output_columns, const std::vector&lt; std::string &gt; &amp;group_operations)</td></tr>
<tr class="separator:acbf17f956c27440e2c6565db68e0b0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22928141ddddd417e0bf75f311aa2ea1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a22928141ddddd417e0bf75f311aa2ea1">groupby_aggregate</a> (const std::vector&lt; std::string &gt; &amp;key_columns, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;group_columns, const std::vector&lt; std::string &gt; &amp;group_output_columns, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt; &amp;group_operations)</td></tr>
<tr class="separator:a22928141ddddd417e0bf75f311aa2ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dad2cb8c7517e36ecdbee7ce348d13"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ad9dad2cb8c7517e36ecdbee7ce348d13">append</a> (std::shared_ptr&lt; unity_sframe_base &gt; other)</td></tr>
<tr class="separator:ad9dad2cb8c7517e36ecdbee7ce348d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86bf264331ecf3743b4a9996e4194c3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#aa86bf264331ecf3743b4a9996e4194c3">pack_columns</a> (const std::vector&lt; std::string &gt; &amp;pack_column_names, const std::vector&lt; std::string &gt; &amp;dict_key_names, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> <a class="el" href="classturi_1_1unity__sframe.html#a8fd3262a93b45910737f785c57d2b5a3">dtype</a>, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;fill_na)</td></tr>
<tr class="separator:aa86bf264331ecf3743b4a9996e4194c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7680f8e2540042a1ecc98d7eedf497ee"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a7680f8e2540042a1ecc98d7eedf497ee">stack</a> (const std::string &amp;<a class="el" href="classturi_1_1unity__sframe.html#abbfa5e9bf78162b65bb5cefe23f89ffc">column_name</a>, const std::vector&lt; std::string &gt; &amp;new_column_names, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;new_column_types, bool drop_na)</td></tr>
<tr class="separator:a7680f8e2540042a1ecc98d7eedf497ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae176acdf81b72fae492f1abcb83fdd65"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#ae176acdf81b72fae492f1abcb83fdd65">copy_range</a> (size_t start, size_t step, size_t end)</td></tr>
<tr class="separator:ae176acdf81b72fae492f1abcb83fdd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13335d79431ec28a83f02e4ae42743d8"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::shared_ptr&lt; unity_sframe_base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#a13335d79431ec28a83f02e4ae42743d8">drop_missing_values</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classturi_1_1unity__sframe.html#a08f9de6c5abca26cd9c3de902c956320">column_names</a>, bool all, bool <a class="el" href="group__eager__algorithms.html#gab9682fbfda1c4eb780e1faafb488c3f0">split</a>)</td></tr>
<tr class="separator:a13335d79431ec28a83f02e4ae42743d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8f23664787da060b452e6b11959c1d"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::shared_ptr&lt; unity_sframe_base &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html#afb8f23664787da060b452e6b11959c1d">logical_filter_split</a> (std::shared_ptr&lt; unity_sarray_base &gt; logical_filter_array)</td></tr>
<tr class="separator:afb8f23664787da060b452e6b11959c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the SFrame object exposed to Python. It stores internally an <a class="el" href="classturi_1_1sframe.html">sframe</a> object which is a collection of named columns, each of flexible type. The SFrame represents a complete immutable collection of columns. Once created, it cannot be modified. However, shallow copies or sub-selection of columns can be created cheaply.</p>
<p>Internally it is simply a single shared_ptr to a <a class="el" href="classturi_1_1sframe.html">sframe</a> object. The sframe construction is delayed until one of the construct calls are made.</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1unity__sframe.html#acf1a6f5e8d3102e6d03154d1627f0b69">unity_sframe</a> frame;</div><div class="line"><span class="comment">// construct</span></div><div class="line">frame.construct(...)</div><div class="line"><span class="comment">// frame is now immutable.</span></div></div><!-- fragment --><p>The SFrame may require temporary on disk storage which will be deleted on program termination. Temporary file names are obtained from <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">turi::get_temp_name</a> </p>

<p class="definition">Definition at line <a class="el" href="unity__sframe_8hpp_source.html#l00052">52</a> of file <a class="el" href="unity__sframe_8hpp_source.html">unity_sframe.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acf1a6f5e8d3102e6d03154d1627f0b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1a6f5e8d3102e6d03154d1627f0b69">&#9670;&nbsp;</a></span>unity_sframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::unity_sframe::unity_sframe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Does nothing </p>

</div>
</div>
<a id="a64182cf0b9259ca8d1a1f9dbad021843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64182cf0b9259ca8d1a1f9dbad021843">&#9670;&nbsp;</a></span>~unity_sframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::unity_sframe::~unity_sframe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Calls <a class="el" href="classturi_1_1unity__sframe.html#a0ef08a07f29d2705a06e645b93c11091">clear()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a890a2faaacff42437ba5bb6266f229a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890a2faaacff42437ba5bb6266f229a2">&#9670;&nbsp;</a></span>_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> turi::unity_sframe::_head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as head, returning dataframe. </p>

</div>
</div>
<a id="ad065dfa621df0a88be920bf36f68471d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad065dfa621df0a88be920bf36f68471d">&#9670;&nbsp;</a></span>_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> turi::unity_sframe::_tail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as head, returning dataframe. </p>

</div>
</div>
<a id="aaf02fd6ca95d55dbbb42028ca543397e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf02fd6ca95d55dbbb42028ca543397e">&#9670;&nbsp;</a></span>add_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::add_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutates the current SFrame by adding the given column.</p>
<p>Throws an exception if:</p><ul>
<li>The given column has a different number of rows than the SFrame. </li>
</ul>

</div>
</div>
<a id="aba9cd6cc6f468214ea4fcd602e42acd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9cd6cc6f468214ea4fcd602e42acd6">&#9670;&nbsp;</a></span>add_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::add_columns </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::shared_ptr&lt; unity_sarray_base &gt;&gt;&#160;</td>
          <td class="paramname"><em>data_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>name_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutates the current SFrame by adding the given columns.</p>
<p>Throws an exception if ANY given column cannot be added (for one of the reasons that add_column can fail).</p>
<dl class="section note"><dt>Note</dt><dd>Currently leaves the SFrame in an unfinished state if one of the columns fails...the columns before that were added successfully will be there. This needs to be changed. </dd></dl>

</div>
</div>
<a id="ad9dad2cb8c7517e36ecdbee7ce348d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dad2cb8c7517e36ecdbee7ce348d13">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::append </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SFrame which contains all rows combined from current SFrame and "other" The "other" SFrame has to have the same number of columns with the same column names and same column types as "this" SFrame </p>

</div>
</div>
<a id="a09e130823dc0fdc11547275b7f713d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e130823dc0fdc11547275b7f713d0d">&#9670;&nbsp;</a></span>begin_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::begin_iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin iteration through the SFrame.</p>
<p>Works together with <a class="el" href="classturi_1_1unity__sframe.html#af42ed6176e1674d62db3c536554cfbad">iterator_get_next()</a>. The usage pattern is as follows: </p><div class="fragment"><div class="line">sframe.begin_iterator();</div><div class="line"><span class="keywordflow">while</span>(1) {</div><div class="line">  <span class="keyword">auto</span> ret = sframe.iterator_get_next(64);</div><div class="line">  <span class="comment">// do stuff</span></div><div class="line">  <span class="keywordflow">if</span> (ret.size() &lt; 64) {</div><div class="line">    <span class="comment">// we are done</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Note that use of pretty much any of the other data-dependent SArray functions will invalidate the iterator. </p>

</div>
</div>
<a id="a0ef08a07f29d2705a06e645b93c11091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef08a07f29d2705a06e645b93c11091">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the contents of the SFrame. </p>

</div>
</div>
<a id="a385c28fb2dc312aea7d6327cecda3802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385c28fb2dc312aea7d6327cecda3802">&#9670;&nbsp;</a></span>column_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sframe::column_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the column <code>name</code> </p>

</div>
</div>
<a id="abbfa5e9bf78162b65bb5cefe23f89ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfa5e9bf78162b65bb5cefe23f89ffc">&#9670;&nbsp;</a></span>column_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; turi::unity_sframe::column_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the column in position <code>index.</code> </p>

</div>
</div>
<a id="a08f9de6c5abca26cd9c3de902c956320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f9de6c5abca26cd9c3de902c956320">&#9670;&nbsp;</a></span>column_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; turi::unity_sframe::column_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array containing the name of each column. The length of the return array is equal to <a class="el" href="classturi_1_1unity__sframe.html#aeed12630d98c2825d44ead9218a399e3">num_columns()</a>. If the sframe is empty, this returns an empty array. </p>

</div>
</div>
<a id="ac26fb4e5ca6342cc28a417c12e18b78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26fb4e5ca6342cc28a417c12e18b78a">&#9670;&nbsp;</a></span>construct_from_csvs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::shared_ptr&lt;unity_sarray_base&gt; &gt; turi::unity_sframe::construct_from_csvs </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td>
          <td class="paramname"><em>parsing_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;&#160;</td>
          <td class="paramname"><em>column_type_hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an SFrame from one or more csv files. To keep the interface stable, the CSV parsing configuration read from a map of string-&gt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> called parsing_config. The URL can be a single filename or a directory name. When passing in a directory and the pattern is non-empty, we will attempt to treat it as a glob pattern.</p>
<p>The default parsing configuration is the following: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> use_header = <span class="keyword">true</span>;</div><div class="line">tokenizer.delimiter = <span class="stringliteral">&quot;,&quot;</span>;</div><div class="line">tokenizer.comment_char = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">tokenizer.escape_char = <span class="charliteral">&#39;\\&#39;</span>;</div><div class="line">tokenizer.double_quote = <span class="keyword">true</span>;</div><div class="line">tokenizer.quote_char = <span class="charliteral">&#39;\&quot;&#39;</span>;</div><div class="line">tokenizer.skip_initial_space = <span class="keyword">true</span>;</div></div><!-- fragment --><p>The fields in parsing config are:</p><ul>
<li>use_header : True if not is_zero()</li>
<li>delimiter : The entire delimiter string</li>
<li>comment_char : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string</li>
<li>escape_char : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string</li>
<li>double_quote : True if not is zero()</li>
<li>quote_char : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string</li>
<li>skip_initial_space : True if not is zero() </li>
</ul>

</div>
</div>
<a id="abf8daf1dcf1f1a5c9ce3f3f90daa4c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8daf1dcf1f1a5c9ce3f3f90daa4c10">&#9670;&nbsp;</a></span>construct_from_dataframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::construct_from_dataframe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> &amp;&#160;</td>
          <td class="paramname"><em>df</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an Sframe using a dataframe as input. Dataframe must not contain NaN values. </p>

</div>
</div>
<a id="a36535542e68005db87cbc35860ee7f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36535542e68005db87cbc35860ee7f7b">&#9670;&nbsp;</a></span>construct_from_sframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::construct_from_sframe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an Sframe using a sframe as input. </p>

</div>
</div>
<a id="ae9f8644a8c177be7de2a0710b209f4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f8644a8c177be7de2a0710b209f4e9">&#9670;&nbsp;</a></span>construct_from_sframe_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::construct_from_sframe_index </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an SFrame from an existing directory on disk saved with <a class="el" href="classturi_1_1unity__sframe.html#a1d21a776859e3c422b83ebd9d50b77b6">save_frame()</a> or a on disk sarray prefix (saved with <a class="el" href="classturi_1_1unity__sframe.html#addea1ba2951b8a8f21c333b4a1430b2f">save_frame_by_index_file()</a>). This function will automatically detect if the location is a directory, or a file. The files will not be deleted on destruction. If the current object is already storing an frame, it is cleared (<a class="el" href="classturi_1_1unity__sframe.html#a0ef08a07f29d2705a06e645b93c11091">clear()</a>). May throw an exception on failure. If an exception occurs, the contents of SArray is empty. </p>

</div>
</div>
<a id="a93850223f37ed71ffb1a5b5f14fb9a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93850223f37ed71ffb1a5b5f14fb9a48">&#9670;&nbsp;</a></span>contains_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sframe::contains_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the column is present in the sframe, and false otherwise. </p>

</div>
</div>
<a id="ae176acdf81b72fae492f1abcb83fdd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae176acdf81b72fae492f1abcb83fdd65">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::copy_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts a range of rows from an SFrame as a new SFrame. This will extract rows beginning at start (inclusive) and ending at end(exclusive) in steps of "step". step must be at least 1. </p>

</div>
</div>
<a id="a13335d79431ec28a83f02e4ae42743d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13335d79431ec28a83f02e4ae42743d8">&#9670;&nbsp;</a></span>drop_missing_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt; &gt; turi::unity_sframe::drop_missing_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SFrame with missing values dropped.</p>
<p>Missing values are only searched for in the columns specified in the 'column_names'. If this vector is empty, all columns will be considered. If 'all' is true, a row is only dropped if all specified columns contain a missing value. If false, the row is dropped if any of the specified columns contain a missing value.</p>
<p>If 'split' is true, this function returns two SFrames, the first being the SFrame with missing values dropped, and the second consisting of all the rows removed.</p>
<p>Throws if the column names are not in this SFrame, or if too many are given. </p>

</div>
</div>
<a id="a8fd3262a93b45910737f785c57d2b5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd3262a93b45910737f785c57d2b5a3">&#9670;&nbsp;</a></span>dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&gt; turi::unity_sframe::dtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array containing the datatype of each column. The length of the return array is equal to <a class="el" href="classturi_1_1unity__sframe.html#aeed12630d98c2825d44ead9218a399e3">num_columns()</a>. If the sframe is empty, this returns an empty array. </p>

</div>
</div>
<a id="ad4077dbd7f360570da490f9117f2043a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4077dbd7f360570da490f9117f2043a">&#9670;&nbsp;</a></span>flat_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::flat_map </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>output_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;&#160;</td>
          <td class="paramname"><em>output_column_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new sarray which is a transform of each row in the sframe using a Python lambda function pickled into a string. </p>

</div>
</div>
<a id="a101e30368649011ff7e73775341edfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101e30368649011ff7e73775341edfd6">&#9670;&nbsp;</a></span>get_planner_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structturi_1_1query__eval_1_1planner__node.html">query_eval::planner_node</a>&gt; turi::unity_sframe::get_planner_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the underlying planner pointer </p>

</div>
</div>
<a id="ad1ad3104a083de00183702ba4eae090b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ad3104a083de00183702ba4eae090b">&#9670;&nbsp;</a></span>get_underlying_sframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::unity_sframe::get_underlying_sframe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the underlying shared_ptr to the sframe object. </p>

</div>
</div>
<a id="acbf17f956c27440e2c6565db68e0b0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf17f956c27440e2c6565db68e0b0d9">&#9670;&nbsp;</a></span>groupby_aggregate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::groupby_aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>key_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>group_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>group_output_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>group_operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns unity_sframe* where there is one row for each unique value of the key_column. group_operations is a collection of pairs of {column_name, operation_name} where operation_name is a builtin operator. </p>

</div>
</div>
<a id="a22928141ddddd417e0bf75f311aa2ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22928141ddddd417e0bf75f311aa2ea1">&#9670;&nbsp;</a></span>groupby_aggregate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::groupby_aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>key_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>group_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>group_output_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>group_operations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4623a0c3398a1303f8774e08d30117ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4623a0c3398a1303f8774e08d30117ca">&#9670;&nbsp;</a></span>has_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sframe::has_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the sframe size is known. </p>

</div>
</div>
<a id="a19ecf0228cf3302a21523be2fc727637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ecf0228cf3302a21523be2fc727637">&#9670;&nbsp;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns some number of rows of the SFrame in a dataframe representation. if nrows exceeds the number of rows in the SFrame ( <a class="el" href="classturi_1_1unity__sframe.html#a849e505ca625f231582a38763be3cc54">size()</a> ), this returns only <a class="el" href="classturi_1_1unity__sframe.html#a849e505ca625f231582a38763be3cc54">size()</a> rows. </p>

</div>
</div>
<a id="aada83f8f216ee397bca507d237cb66c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada83f8f216ee397bca507d237cb66c2">&#9670;&nbsp;</a></span>is_materialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sframe::is_materialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not this sframe is materialized </p>

</div>
</div>
<a id="af42ed6176e1674d62db3c536554cfbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42ed6176e1674d62db3c536554cfbad">&#9670;&nbsp;</a></span>iterator_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::unity_sframe::iterator_get_next </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the next block of elements of size len from the SFrame. Works together with <a class="el" href="classturi_1_1unity__sframe.html#a09e130823dc0fdc11547275b7f713d0d">begin_iterator()</a>. See the code example in <a class="el" href="classturi_1_1unity__sframe.html#a09e130823dc0fdc11547275b7f713d0d">begin_iterator()</a> for details.</p>
<p>This function will always return a vector of length 'len' unless at the end of the array, or if an error has occured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The number of elements to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next collection of elements in the array. Returns less then len elements on end of file or failure. </dd></dl>

</div>
</div>
<a id="aa618b984e2e381286866a34e74884d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa618b984e2e381286866a34e74884d62">&#9670;&nbsp;</a></span>logical_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::logical_filter </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SFrame which is filtered by a given logical column. The index array must be the same length as the current array. An output array is returned containing only the elements in the current where are the corresponding element in the index array evaluates to true. </p>

</div>
</div>
<a id="afb8f23664787da060b452e6b11959c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8f23664787da060b452e6b11959c1d">&#9670;&nbsp;</a></span>logical_filter_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt; &gt; turi::unity_sframe::logical_filter_split </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>logical_filter_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to logical filter, but return both positive and negative rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logical_filter_array</td><td>is an sarray of the same size, and has only zeros and ones as value.</td></tr>
  </table>
  </dd>
</dl>
<p>Return a list of two sframes with all positive examples goes to the first one and negative rows goes to the second one. </p>

</div>
</div>
<a id="a67bed7000cb61f1b872ffec02e0be6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bed7000cb61f1b872ffec02e0be6aa">&#9670;&nbsp;</a></span>materialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::materialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>materialize the sframe, this is different from save() as this is a temporary persist of all sarrays underneath the sframe to speed up some computation (for example, lambda) this will NOT create a new uity_sframe. </p>

</div>
</div>
<a id="aeed12630d98c2825d44ead9218a399e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed12630d98c2825d44ead9218a399e3">&#9670;&nbsp;</a></span>num_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sframe::num_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of columns in the SFrame. Returns 0 if the sframe is empty. </p>

</div>
</div>
<a id="aa86bf264331ecf3743b4a9996e4194c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86bf264331ecf3743b4a9996e4194c3">&#9670;&nbsp;</a></span>pack_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sframe::pack_columns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>pack_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dict_key_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>fill_na</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack a subset columns of current SFrame into one dictionary column, using column name as key in the dictionary, and value of the column as value in the dictionary, returns a new SFrame that includes other non-packed columns plus the newly generated dict column. Missing value in the original column will not show up in the packed dictionary value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pack_column_names</td><td>: list of column names to pack </td></tr>
    <tr><td class="paramname">dict_key_names</td><td>: dictionary key name to give to the packed dictionary </td></tr>
    <tr><td class="paramname">dtype</td><td>the result SArray type missing value is maintained, it could be filled with fill_na value is specified. </td></tr>
    <tr><td class="paramname">fill_na</td><td>the value to fill when missing value is encountered</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new SArray that contains the newly packed column </p>

</div>
</div>
<a id="a674c877978344bdc5e86377c7cf51f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674c877978344bdc5e86377c7cf51f8a">&#9670;&nbsp;</a></span>query_plan_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::unity_sframe::query_plan_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the query plan as a string representation of a dot graph. </p>

</div>
</div>
<a id="a492e7835faf826c5f9b2a3791461046f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e7835faf826c5f9b2a3791461046f">&#9670;&nbsp;</a></span>random_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt; &gt; turi::unity_sframe::random_split </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>random_seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Randomly split the sframe into two parts, with ratio = percent, and seed = random_seed.</p>
<p>Returns a list of size 2 of the unity_sframes resulting from the split. </p>

</div>
</div>
<a id="a99926f25180b64e4edefa764247cb349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99926f25180b64e4edefa764247cb349">&#9670;&nbsp;</a></span>remove_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::remove_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the ith column. </p>

</div>
</div>
<a id="a9a9ca30e0d5c905c0464ad28858acb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9ca30e0d5c905c0464ad28858acb54">&#9670;&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::sample </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>random_seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sample the rows of sframe uniformly with ratio = percent, and seed = random_seed.</p>
<p>Returns unity_sframe* containing the sampled rows. </p>

</div>
</div>
<a id="a1bda760503bd25757ceff82fcd4830b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda760503bd25757ceff82fcd4830b0">&#9670;&nbsp;</a></span>save_as_csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::save_as_csv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td>
          <td class="paramname"><em>writing_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the sframe to url in csv format. To keep the interface stable, the CSV parsing configuration read from a map of string-&gt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> called writing_config.</p>
<p>The default writing configuration is the following: </p><div class="fragment"><div class="line">writer.delimiter = <span class="stringliteral">&quot;,&quot;</span>;</div><div class="line">writer.escape_char = <span class="charliteral">&#39;\\&#39;</span>;</div><div class="line">writer.double_quote = <span class="keyword">true</span>;</div><div class="line">writer.quote_char = <span class="charliteral">&#39;\&quot;&#39;</span>;</div><div class="line">writer.use_quote_char = <span class="keyword">true</span>;</div></div><!-- fragment --><p>For details on the meaning of each config see <a class="el" href="classturi_1_1csv__writer.html">csv_writer</a></p>
<p>The fields in parsing config are:</p><ul>
<li>delimiter : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string</li>
<li>escape_char : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string</li>
<li>double_quote : True if not is zero()</li>
<li>quote_char : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string</li>
<li>use_quote_char : First character if <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a string </li>
</ul>

</div>
</div>
<a id="a1d21a776859e3c422b83ebd9d50b77b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d21a776859e3c422b83ebd9d50b77b6">&#9670;&nbsp;</a></span>save_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::save_frame </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a copy of the current sframe into a directory. Does not modify the current sframe. </p>

</div>
</div>
<a id="addea1ba2951b8a8f21c333b4a1430b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addea1ba2951b8a8f21c333b4a1430b2f">&#9670;&nbsp;</a></span>save_frame_by_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::save_frame_by_index_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a copy of the current sframe into a target location defined by an index file. DOes not modify the current sframe. </p>

</div>
</div>
<a id="a8f383f45511896dbc7579feb130ba9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f383f45511896dbc7579feb130ba9e1">&#9670;&nbsp;</a></span>save_frame_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::save_frame_reference </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an incomplete save of an existing SFrame into a directory. This saved SFrame may reference SFrames in other locations <em>in the same filesystem</em> for certain columns/segments/etc.</p>
<p>Does not modify the current sframe. </p>

</div>
</div>
<a id="ad1553568db9179d9cea749e9386d45cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1553568db9179d9cea749e9386d45cf">&#9670;&nbsp;</a></span>select_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sframe::select_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an SArray with the column that corresponds to 'name'. Throws an exception if the name is not in the current SFrame. </p>

</div>
</div>
<a id="ae2b8f7b00d84439fa50c7282aa0e9dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b8f7b00d84439fa50c7282aa0e9dd3">&#9670;&nbsp;</a></span>select_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::select_columns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an lazy sframe with the columns that have the given names. Throws an exception if ANY of the names given are not in the current SFrame. </p>

</div>
</div>
<a id="ad63cf8315424dbef4da3b09a3e1827ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63cf8315424dbef4da3b09a3e1827ac">&#9670;&nbsp;</a></span>set_column_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::set_column_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the ith column name.</p>
<p>Throws an exception if index out of bound or name already exists. </p>

</div>
</div>
<a id="af9f9ec8d04de7d05c5a30b5870ee4dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f9ec8d04de7d05c5a30b5870ee4dd5">&#9670;&nbsp;</a></span>set_sframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::set_sframe </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sf_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the private shared pointer to an sframe. </p>

</div>
</div>
<a id="a849e505ca625f231582a38763be3cc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849e505ca625f231582a38763be3cc54">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sframe::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of rows in the SFrame. Returns 0 if the SFrame is empty. </p>

</div>
</div>
<a id="a7680f8e2540042a1ecc98d7eedf497ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7680f8e2540042a1ecc98d7eedf497ee">&#9670;&nbsp;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::stack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_column_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop_na</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a dictionary column of the SFrame to two columns with first column as the key for the dictionary and second column as the value for the dictionary. Returns a new SFrame with the two newly created columns, plus all columns other than the stacked column. The values from those columns are duplicated for all rows created from the same original row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name</td><td>string The column to stack. The name must come from current SFrame and must be of dict type</td></tr>
    <tr><td class="paramname">new_column_names</td><td>a list of str, optional Must be length of two. The two column names to stack the dict value to. If not given, the name is automatically generated.</td></tr>
    <tr><td class="paramname">new_column_types</td><td>a list of types, optional Must be length of two. The type for the newly created column. If not given, the default to [str, int].</td></tr>
    <tr><td class="paramname">drop_na</td><td>if true, missing values from dictionary will be ignored. If false, for missing dict value, one row will be created with the two new columns' value being missing value</td></tr>
  </table>
  </dd>
</dl>
<p>Retruns a new <a class="el" href="classturi_1_1unity__sframe.html">unity_sframe</a> with stacked columns </p>

</div>
</div>
<a id="a0cc2c9ab6a838167e617db9fda7056c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc2c9ab6a838167e617db9fda7056c4">&#9670;&nbsp;</a></span>swap_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sframe::swap_columns </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the ith and jth columns. </p>

</div>
</div>
<a id="ad2e414417d80b5a0b4242f57050314ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e414417d80b5a0b4242f57050314ff">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sframe::tail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns some number of rows from the end of the SFrame in a dataframe representation. If nrows exceeds the number of rows in the SFrame ( <a class="el" href="classturi_1_1unity__sframe.html#a849e505ca625f231582a38763be3cc54">size()</a> ), this returns only <a class="el" href="classturi_1_1unity__sframe.html#a849e505ca625f231582a38763be3cc54">size()</a> rows. </p>

</div>
</div>
<a id="a27f5a59c446df522fd6dd6e08dc6079e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f5a59c446df522fd6dd6e08dc6079e">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sframe::transform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new sarray which is a transform of each row in the sframe using a Python lambda function pickled into a string. </p>

</div>
</div>
<a id="af9f632b4471babf843ce37c4cf6aae1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f632b4471babf843ce37c4cf6aae1d">&#9670;&nbsp;</a></span>transform_lambda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sframe::transform_lambda </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>(const <a class="el" href="structturi_1_1sframe__rows_1_1row.html">sframe_rows::row</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new sarray which is a transform of each row in the sframe using a Python lambda function pickled into a string. </p>

</div>
</div>
<a id="ac29cf5557069d505f7ec2914a3c09e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29cf5557069d505f7ec2914a3c09e37">&#9670;&nbsp;</a></span>transform_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sframe::transform_native </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new sarray which is a transform of each row in the sframe using a Python lambda function pickled into a string. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>unity/lib/<a class="el" href="unity__sframe_8hpp_source.html">unity_sframe.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1unity__sframe.html">unity_sframe</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
