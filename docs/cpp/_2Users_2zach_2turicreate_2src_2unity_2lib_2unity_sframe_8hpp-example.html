<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: /Users/zach/turicreate/src/unity/lib/unity_sframe.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_2Users_2zach_2turicreate_2src_2unity_2lib_2unity_sframe_8hpp-example.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/Users/zach/turicreate/src/unity/lib/unity_sframe.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Generate a new column name</p>
<p>New column name is in the form of X1, X2, X3 .... In case of conflict, add .1, .2 until conflict is resolved.</p>
<p>Given current sframe column names: a, b, c Next 3 generated names are: X4, X5, X6</p>
<p>Given current sframe column names: X4, X5.1, X6.2 Next 3 generated names are: X4.1, X5, X6.1</p>
<div class="fragment"><div class="line"><span class="comment">/* Copyright Â© 2017 Apple Inc. All rights reserved.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Use of this source code is governed by a BSD-3-clause license that can</span></div><div class="line"><span class="comment"> * be found in the LICENSE.txt file or at https://opensource.org/licenses/BSD-3-Clause</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#ifndef TURI_UNITY_SFRAME_HPP</span></div><div class="line"><span class="preprocessor">#define TURI_UNITY_SFRAME_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unity/lib/api/unity_sframe_interface.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unity/lib/unity_sarray.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sframe/group_aggregate_value.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sframe/sframe_rows.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unity/lib/visualization/plot.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line"></div><div class="line"><span class="comment">// forward declarations</span></div><div class="line"><span class="keyword">class </span>sframe;</div><div class="line"><span class="keyword">class </span>dataframe;</div><div class="line"><span class="keyword">class </span>sframe_reader;</div><div class="line"><span class="keyword">class </span>sframe_iterator;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>query_eval {</div><div class="line"><span class="keyword">class </span>planner_node;</div><div class="line">} <span class="comment">// query_eval</span></div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * This is the SFrame object exposed to Python. It stores internally an</span></div><div class="line"><span class="comment"> * \ref sframe object which is a collection of named columns, each of flexible</span></div><div class="line"><span class="comment"> * type. The SFrame represents a complete immutable collection of columns.</span></div><div class="line"><span class="comment"> * Once created, it cannot be modified. However, shallow copies or sub-selection</span></div><div class="line"><span class="comment"> * of columns can be created cheaply.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Internally it is simply a single shared_ptr to a \ref sframe object. The</span></div><div class="line"><span class="comment"> * sframe construction is delayed until one of the construct calls are made.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \code</span></div><div class="line"><span class="comment"> * unity_sframe frame;</span></div><div class="line"><span class="comment"> * // construct</span></div><div class="line"><span class="comment"> * frame.construct(...)</span></div><div class="line"><span class="comment"> * // frame is now immutable.</span></div><div class="line"><span class="comment"> * \endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The SFrame may require temporary on disk storage which will be deleted</span></div><div class="line"><span class="comment"> * on program termination. Temporary file names are obtained from</span></div><div class="line"><span class="comment"> * \ref turi::get_temp_name</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class </span>unity_sframe : <span class="keyword">public</span> unity_sframe_base {</div><div class="line"> <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Default constructor. Does nothing</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <a name="a0"></a><a class="code" href="classturi_1_1unity__sframe.html#acf1a6f5e8d3102e6d03154d1627f0b69">unity_sframe</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Destructor. Calls clear().</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <a name="a1"></a><a class="code" href="classturi_1_1unity__sframe.html#a64182cf0b9259ca8d1a1f9dbad021843">~unity_sframe</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an Sframe using a dataframe as input.</span></div><div class="line"><span class="comment">   * Dataframe must not contain NaN values.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a2"></a><a class="code" href="classturi_1_1unity__sframe.html#abf8daf1dcf1f1a5c9ce3f3f90daa4c10">construct_from_dataframe</a>(<span class="keyword">const</span> dataframe_t&amp; df);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an Sframe using a sframe as input.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a3"></a><a class="code" href="classturi_1_1unity__sframe.html#a36535542e68005db87cbc35860ee7f7b">construct_from_sframe</a>(<span class="keyword">const</span> sframe&amp; sf);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an SFrame from an existing directory on disk saved with</span></div><div class="line"><span class="comment">   * save_frame() or a on disk sarray prefix (saved with</span></div><div class="line"><span class="comment">   * save_frame_by_index_file()). This function will automatically detect if</span></div><div class="line"><span class="comment">   * the location is a directory, or a file. The files will not be deleted on</span></div><div class="line"><span class="comment">   * destruction.  If the current object is already storing an frame, it is</span></div><div class="line"><span class="comment">   * cleared (\ref clear()). May throw an exception on failure. If an exception</span></div><div class="line"><span class="comment">   * occurs, the contents of SArray is empty.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a4"></a><a class="code" href="classturi_1_1unity__sframe.html#ae9f8644a8c177be7de2a0710b209f4e9">construct_from_sframe_index</a>(std::string index_file);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an SFrame from one or more csv files.</span></div><div class="line"><span class="comment">   * To keep the interface stable, the CSV parsing configuration read from a</span></div><div class="line"><span class="comment">   * map of string-&gt;flexible_type called parsing_config. The URL can be a single</span></div><div class="line"><span class="comment">   * filename or a directory name. When passing in a directory and the pattern</span></div><div class="line"><span class="comment">   * is non-empty, we will attempt to treat it as a glob pattern.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The default parsing configuration is the following:</span></div><div class="line"><span class="comment">   * \code</span></div><div class="line"><span class="comment">   * bool use_header = true;</span></div><div class="line"><span class="comment">   * tokenizer.delimiter = &quot;,&quot;;</span></div><div class="line"><span class="comment">   * tokenizer.comment_char = &#39;\0&#39;;</span></div><div class="line"><span class="comment">   * tokenizer.escape_char = &#39;\\&#39;;</span></div><div class="line"><span class="comment">   * tokenizer.double_quote = true;</span></div><div class="line"><span class="comment">   * tokenizer.quote_char = &#39;\&quot;&#39;;</span></div><div class="line"><span class="comment">   * tokenizer.skip_initial_space = true;</span></div><div class="line"><span class="comment">   * \endcode</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The fields in parsing config are:</span></div><div class="line"><span class="comment">   *  - use_header : True if not is_zero()</span></div><div class="line"><span class="comment">   *  - delimiter : The entire delimiter string</span></div><div class="line"><span class="comment">   *  - comment_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - escape_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - double_quote : True if not is zero()</span></div><div class="line"><span class="comment">   *  - quote_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - skip_initial_space : True if not is zero()</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::map&lt;std::string, std::shared_ptr&lt;unity_sarray_base&gt;&gt; <a name="a5"></a><a class="code" href="classturi_1_1unity__sframe.html#ac26fb4e5ca6342cc28a417c12e18b78a">construct_from_csvs</a>(</div><div class="line">      std::string url,</div><div class="line">      std::map&lt;std::string, flexible_type&gt; parsing_config,</div><div class="line">      std::map&lt;std::string, flex_type_enum&gt; column_type_hints);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> construct_from_planner_node(std::shared_ptr&lt;query_eval::planner_node&gt; node,</div><div class="line">                                   <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; <a name="a6"></a><a class="code" href="classturi_1_1unity__sframe.html#a08f9de6c5abca26cd9c3de902c956320">column_names</a>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Saves a copy of the current sframe into a directory.</span></div><div class="line"><span class="comment">   * Does not modify the current sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a7"></a><a class="code" href="classturi_1_1unity__sframe.html#a1d21a776859e3c422b83ebd9d50b77b6">save_frame</a>(std::string target_directory);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Performs an incomplete save of an existing SFrame into a directory.</span></div><div class="line"><span class="comment">   * This saved SFrame may reference SFrames in other locations *in the same</span></div><div class="line"><span class="comment">   * filesystem* for certain columns/segments/etc.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Does not modify the current sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a8"></a><a class="code" href="classturi_1_1unity__sframe.html#a8f383f45511896dbc7579feb130ba9e1">save_frame_reference</a>(std::string target_directory);</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Saves a copy of the current sframe into a target location defined by</span></div><div class="line"><span class="comment">   * an index file. DOes not modify the current sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a9"></a><a class="code" href="classturi_1_1unity__sframe.html#addea1ba2951b8a8f21c333b4a1430b2f">save_frame_by_index_file</a>(std::string index_file);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Clears the contents of the SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a10"></a><a class="code" href="classturi_1_1unity__sframe.html#a0ef08a07f29d2705a06e645b93c11091">clear</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the number of rows in the SFrame. Returns 0 if the SFrame is empty.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> <a name="a11"></a><a class="code" href="classturi_1_1unity__sframe.html#a849e505ca625f231582a38763be3cc54">size</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the number of columns in the SFrame.</span></div><div class="line"><span class="comment">   * Returns 0 if the sframe is empty.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> <a name="a12"></a><a class="code" href="classturi_1_1unity__sframe.html#aeed12630d98c2825d44ead9218a399e3">num_columns</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an array containing the datatype of each column. The length</span></div><div class="line"><span class="comment">   * of the return array is equal to num_columns(). If the sframe is empty,</span></div><div class="line"><span class="comment">   * this returns an empty array.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt;flex_type_enum&gt; <a name="a13"></a><a class="code" href="classturi_1_1unity__sframe.html#a8fd3262a93b45910737f785c57d2b5a3">dtype</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an array containing the name of each column. The length</span></div><div class="line"><span class="comment">   * of the return array is equal to num_columns(). If the sframe is empty,</span></div><div class="line"><span class="comment">   * this returns an empty array.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt;std::string&gt; <a class="code" href="classturi_1_1unity__sframe.html#a08f9de6c5abca26cd9c3de902c956320">column_names</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns some number of rows of the SFrame in a dataframe representation.</span></div><div class="line"><span class="comment">   * if nrows exceeds the number of rows in the SFrame ( \ref size() ), this</span></div><div class="line"><span class="comment">   * returns only \ref size() rows.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a14"></a><a class="code" href="classturi_1_1unity__sframe.html#a19ecf0228cf3302a21523be2fc727637">head</a>(<span class="keywordtype">size_t</span> nrows);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   *  Returns the index of the column `name`</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> <a name="a15"></a><a class="code" href="classturi_1_1unity__sframe.html#a385c28fb2dc312aea7d6327cecda3802">column_index</a>(<span class="keyword">const</span> std::string&amp; name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   *  Returns the name of the column in position `index.`</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">const</span> std::string&amp; <a name="a16"></a><a class="code" href="classturi_1_1unity__sframe.html#abbfa5e9bf78162b65bb5cefe23f89ffc">column_name</a>(<span class="keywordtype">size_t</span> index);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns true if the column is present in the sframe, and false</span></div><div class="line"><span class="comment">   * otherwise.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">bool</span> <a name="a17"></a><a class="code" href="classturi_1_1unity__sframe.html#a93850223f37ed71ffb1a5b5f14fb9a48">contains_column</a>(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Same as head, returning dataframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  dataframe_t <a name="a18"></a><a class="code" href="classturi_1_1unity__sframe.html#a890a2faaacff42437ba5bb6266f229a2">_head</a>(<span class="keywordtype">size_t</span> nrows);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns some number of rows from the end of the SFrame in a dataframe</span></div><div class="line"><span class="comment">   * representation. If nrows exceeds the number of rows in the SFrame</span></div><div class="line"><span class="comment">   * ( \ref size() ), this returns only \ref size() rows.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a19"></a><a class="code" href="classturi_1_1unity__sframe.html#ad2e414417d80b5a0b4242f57050314ff">tail</a>(<span class="keywordtype">size_t</span> nrows);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Same as head, returning dataframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  dataframe_t <a name="a20"></a><a class="code" href="classturi_1_1unity__sframe.html#ad065dfa621df0a88be920bf36f68471d">_tail</a>(<span class="keywordtype">size_t</span> nrows);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an SArray with the column that corresponds to &#39;name&#39;.  Throws an</span></div><div class="line"><span class="comment">   * exception if the name is not in the current SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; <a name="a21"></a><a class="code" href="classturi_1_1unity__sframe.html#ad1553568db9179d9cea749e9386d45cf">select_column</a>(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new SFrame which is filtered by a given logical column.</span></div><div class="line"><span class="comment">   * The index array must be the same length as the current array. An output</span></div><div class="line"><span class="comment">   * array is returned containing only the elements in the current where are the</span></div><div class="line"><span class="comment">   * corresponding element in the index array evaluates to true.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a22"></a><a class="code" href="classturi_1_1unity__sframe.html#aa618b984e2e381286866a34e74884d62">logical_filter</a>(std::shared_ptr&lt;unity_sarray_base&gt; index);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an lazy sframe with the columns that have the given names. Throws an</span></div><div class="line"><span class="comment">   * exception if ANY of the names given are not in the current SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a23"></a><a class="code" href="classturi_1_1unity__sframe.html#ae2b8f7b00d84439fa50c7282aa0e9dd3">select_columns</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;names);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Mutates the current SFrame by adding the given column.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws an exception if:</span></div><div class="line"><span class="comment">   *  - The given column has a different number of rows than the SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a24"></a><a class="code" href="classturi_1_1unity__sframe.html#aaf02fd6ca95d55dbbb42028ca543397e">add_column</a>(std::shared_ptr&lt;unity_sarray_base &gt;data, <span class="keyword">const</span> std::string &amp;name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Mutates the current SFrame by adding the given columns.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws an exception if ANY given column cannot be added</span></div><div class="line"><span class="comment">   * (for one of the reasons that add_column can fail).</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \note Currently leaves the SFrame in an unfinished state if one of the</span></div><div class="line"><span class="comment">   * columns fails...the columns before that were added successfully will</span></div><div class="line"><span class="comment">   * be there. This needs to be changed.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a25"></a><a class="code" href="classturi_1_1unity__sframe.html#aba9cd6cc6f468214ea4fcd602e42acd6">add_columns</a>(std::list&lt;std::shared_ptr&lt;unity_sarray_base&gt;&gt; data_list,</div><div class="line">                   std::vector&lt;std::string&gt; name_vec);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; <a name="a26"></a><a class="code" href="classturi_1_1unity__sframe.html#a27f5a59c446df522fd6dd6e08dc6079e">transform</a>(<span class="keyword">const</span> std::string&amp; lambda,</div><div class="line">                                               <a name="a27"></a><a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type,</div><div class="line">                                               <span class="keywordtype">bool</span> skip_undefined,</div><div class="line">                                               <span class="keywordtype">int</span> <a name="a28"></a><a class="code" href="group__random.html#ga2a9e1d70141f65d9de3a2f2fe45a0d88">seed</a>);</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; <a name="a29"></a><a class="code" href="classturi_1_1unity__sframe.html#ac29cf5557069d505f7ec2914a3c09e37">transform_native</a>(<span class="keyword">const</span> function_closure_info&amp; lambda,</div><div class="line">                                                      <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type,</div><div class="line">                                                      <span class="keywordtype">bool</span> skip_undefined,</div><div class="line">                                                      <span class="keywordtype">int</span> <a class="code" href="group__random.html#ga2a9e1d70141f65d9de3a2f2fe45a0d88">seed</a>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; <a name="a30"></a><a class="code" href="classturi_1_1unity__sframe.html#af9f632b4471babf843ce37c4cf6aae1d">transform_lambda</a>(</div><div class="line">      std::function&lt;flexible_type(<span class="keyword">const</span> sframe_rows::row&amp;)&gt; lambda,</div><div class="line">      <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type,</div><div class="line">      <span class="keywordtype">int</span> <a class="code" href="group__random.html#ga2a9e1d70141f65d9de3a2f2fe45a0d88">seed</a>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a31"></a><a class="code" href="classturi_1_1unity__sframe.html#ad4077dbd7f360570da490f9117f2043a">flat_map</a>(<span class="keyword">const</span> std::string&amp; lambda,</div><div class="line">                                              std::vector&lt;std::string&gt; output_column_names,</div><div class="line">                                              std::vector&lt;flex_type_enum&gt; output_column_types,</div><div class="line">                                              <span class="keywordtype">bool</span> skip_undefined,</div><div class="line">                                              <span class="keywordtype">int</span> <a class="code" href="group__random.html#ga2a9e1d70141f65d9de3a2f2fe45a0d88">seed</a>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Set the ith column name.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws an exception if index out of bound or name already exists.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a32"></a><a class="code" href="classturi_1_1unity__sframe.html#ad63cf8315424dbef4da3b09a3e1827ac">set_column_name</a>(<span class="keywordtype">size_t</span> i, std::string name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Remove the ith column.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a33"></a><a class="code" href="classturi_1_1unity__sframe.html#a99926f25180b64e4edefa764247cb349">remove_column</a>(<span class="keywordtype">size_t</span> i);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Swap the ith and jth columns.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a34"></a><a class="code" href="classturi_1_1unity__sframe.html#a0cc2c9ab6a838167e617db9fda7056c4">swap_columns</a>(<span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> j);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the underlying shared_ptr to the sframe object.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;sframe&gt; <a name="a35"></a><a class="code" href="classturi_1_1unity__sframe.html#ad1ad3104a083de00183702ba4eae090b">get_underlying_sframe</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the underlying planner pointer</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;query_eval::planner_node&gt; <a name="a36"></a><a class="code" href="classturi_1_1unity__sframe.html#a101e30368649011ff7e73775341edfd6">get_planner_node</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Sets the private shared pointer to an sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a37"></a><a class="code" href="classturi_1_1unity__sframe.html#af9f9ec8d04de7d05c5a30b5870ee4dd5">set_sframe</a>(<span class="keyword">const</span> std::shared_ptr&lt;sframe&gt;&amp; sf_ptr);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Begin iteration through the SFrame.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Works together with \ref iterator_get_next(). The usage pattern</span></div><div class="line"><span class="comment">   * is as follows:</span></div><div class="line"><span class="comment">   * \code</span></div><div class="line"><span class="comment">   * sframe.begin_iterator();</span></div><div class="line"><span class="comment">   * while(1) {</span></div><div class="line"><span class="comment">   *   auto ret = sframe.iterator_get_next(64);</span></div><div class="line"><span class="comment">   *   // do stuff</span></div><div class="line"><span class="comment">   *   if (ret.size() &lt; 64) {</span></div><div class="line"><span class="comment">   *     // we are done</span></div><div class="line"><span class="comment">   *     break;</span></div><div class="line"><span class="comment">   *   }</span></div><div class="line"><span class="comment">   * }</span></div><div class="line"><span class="comment">   * \endcode</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Note that use of pretty much any of the other data-dependent SArray</span></div><div class="line"><span class="comment">   * functions will invalidate the iterator.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a38"></a><a class="code" href="classturi_1_1unity__sframe.html#a09e130823dc0fdc11547275b7f713d0d">begin_iterator</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Obtains the next block of elements of size len from the SFrame.</span></div><div class="line"><span class="comment">   * Works together with \ref begin_iterator(). See the code example</span></div><div class="line"><span class="comment">   * in \ref begin_iterator() for details.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * This function will always return a vector of length &#39;len&#39; unless</span></div><div class="line"><span class="comment">   * at the end of the array, or if an error has occured.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \param len The number of elements to return</span></div><div class="line"><span class="comment">   * \returns The next collection of elements in the array. Returns less then</span></div><div class="line"><span class="comment">   * len elements on end of file or failure.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt; std::vector&lt;flexible_type&gt; &gt; <a name="a39"></a><a class="code" href="classturi_1_1unity__sframe.html#af42ed6176e1674d62db3c536554cfbad">iterator_get_next</a>(<span class="keywordtype">size_t</span> len);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Save the sframe to url in csv format.</span></div><div class="line"><span class="comment">   * To keep the interface stable, the CSV parsing configuration read from a</span></div><div class="line"><span class="comment">   * map of string-&gt;flexible_type called writing_config.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The default writing configuration is the following:</span></div><div class="line"><span class="comment">   * \code</span></div><div class="line"><span class="comment">   * writer.delimiter = &quot;,&quot;;</span></div><div class="line"><span class="comment">   * writer.escape_char = &#39;\\&#39;;</span></div><div class="line"><span class="comment">   * writer.double_quote = true;</span></div><div class="line"><span class="comment">   * writer.quote_char = &#39;\&quot;&#39;;</span></div><div class="line"><span class="comment">   * writer.use_quote_char = true;</span></div><div class="line"><span class="comment">   * \endcode</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * For details on the meaning of each config see \ref csv_writer</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The fields in parsing config are:</span></div><div class="line"><span class="comment">   *  - delimiter : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - escape_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - double_quote : True if not is zero()</span></div><div class="line"><span class="comment">   *  - quote_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - use_quote_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a40"></a><a class="code" href="classturi_1_1unity__sframe.html#a1bda760503bd25757ceff82fcd4830b0">save_as_csv</a>(<span class="keyword">const</span> std::string&amp; url,</div><div class="line">                   std::map&lt;std::string, flexible_type&gt; writing_config);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Randomly split the sframe into two parts, with ratio = percent, and  seed = random_seed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Returns a list of size 2 of the unity_sframes resulting from the split.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt;&gt; <a name="a41"></a><a class="code" href="classturi_1_1unity__sframe.html#a8f101fe2ee6c572f6d3258088e18cbbb">random_split</a>(<span class="keywordtype">float</span> percent, <span class="keywordtype">int</span> random_seed, <span class="keywordtype">bool</span> exact=<span class="keyword">false</span>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Sample the rows of sframe uniformly with ratio = percent, and seed = random_seed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Returns unity_sframe* containing the sampled rows.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a42"></a><a class="code" href="classturi_1_1unity__sframe.html#af9b092b5e03cf5852f17f7c0b092d28d">sample</a>(<span class="keywordtype">float</span> percent, <span class="keywordtype">int</span> random_seed, <span class="keywordtype">bool</span> exact=<span class="keyword">false</span>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * materialize the sframe, this is different from save() as this is a temporary persist of</span></div><div class="line"><span class="comment">   * all sarrays underneath the sframe to speed up some computation (for example, lambda)</span></div><div class="line"><span class="comment">   * this will NOT create a new uity_sframe.</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  <span class="keywordtype">void</span> <a name="a43"></a><a class="code" href="classturi_1_1unity__sframe.html#a67bed7000cb61f1b872ffec02e0be6aa">materialize</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns whether or not this sframe is materialized</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">  <span class="keywordtype">bool</span> <a name="a44"></a><a class="code" href="classturi_1_1unity__sframe.html#aada83f8f216ee397bca507d237cb66c2">is_materialized</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Return the query plan as a string representation of a dot graph.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::string <a name="a45"></a><a class="code" href="classturi_1_1unity__sframe.html#a674c877978344bdc5e86377c7cf51f8a">query_plan_string</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Return true if the sframe size is known.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">bool</span> <a name="a46"></a><a class="code" href="classturi_1_1unity__sframe.html#a4623a0c3398a1303f8774e08d30117ca">has_size</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns unity_sframe* where there is one row for each unique value of the</span></div><div class="line"><span class="comment">   * key_column.</span></div><div class="line"><span class="comment">   * group_operations is a collection of pairs of {column_name, operation_name}</span></div><div class="line"><span class="comment">   * where operation_name is a builtin operator.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a47"></a><a class="code" href="classturi_1_1unity__sframe.html#acbf17f956c27440e2c6565db68e0b0d9">groupby_aggregate</a>(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; key_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; group_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; group_output_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; group_operations);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * \overload</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a class="code" href="classturi_1_1unity__sframe.html#acbf17f956c27440e2c6565db68e0b0d9">groupby_aggregate</a>(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; key_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; group_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; group_output_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;group_aggregate_value&gt;&gt;&amp; group_operations);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new SFrame which contains all rows combined from current SFrame and &quot;other&quot;</span></div><div class="line"><span class="comment">   * The &quot;other&quot; SFrame has to have the same number of columns with the same column names</span></div><div class="line"><span class="comment">   * and same column types as &quot;this&quot; SFrame</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a48"></a><a class="code" href="classturi_1_1unity__sframe.html#ad9dad2cb8c7517e36ecdbee7ce348d13">append</a>(std::shared_ptr&lt;unity_sframe_base&gt; other);</div><div class="line"></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; join(std::shared_ptr&lt;unity_sframe_base &gt;right,</div><div class="line">                          <span class="keyword">const</span> std::string join_type,</div><div class="line">                          std::map&lt;std::string,std::string&gt; join_keys);</div><div class="line"></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; sort(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; sort_keys,</div><div class="line">                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; sort_ascending);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">    * Pack a subset columns of current SFrame into one dictionary column, using</span></div><div class="line"><span class="comment">    * column name as key in the dictionary, and value of the column as value</span></div><div class="line"><span class="comment">    * in the dictionary, returns a new SFrame that includes other non-packed</span></div><div class="line"><span class="comment">    * columns plus the newly generated dict column.</span></div><div class="line"><span class="comment">    * Missing value in the original column will not show up in the packed</span></div><div class="line"><span class="comment">    * dictionary value.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    * \param pack_column_names : list of column names to pack</span></div><div class="line"><span class="comment">    * \param dict_key_names : dictionary key name to give to the packed dictionary</span></div><div class="line"><span class="comment">    * \param dtype: the result SArray type</span></div><div class="line"><span class="comment">      missing value is maintained, it could be filled with fill_na value is specified.</span></div><div class="line"><span class="comment">    * \param fill_na: the value to fill when missing value is encountered</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    * Returns a new SArray that contains the newly packed column</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; <a name="a49"></a><a class="code" href="classturi_1_1unity__sframe.html#aa86bf264331ecf3743b4a9996e4194c3">pack_columns</a>(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; pack_column_names,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; dict_key_names,</div><div class="line">      <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> <a class="code" href="classturi_1_1unity__sframe.html#a8fd3262a93b45910737f785c57d2b5a3">dtype</a>,</div><div class="line">      <span class="keyword">const</span> flexible_type&amp; fill_na);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Convert a dictionary column of the SFrame to two columns with first column</span></div><div class="line"><span class="comment">   * as the key for the dictionary and second column as the value for the</span></div><div class="line"><span class="comment">   * dictionary. Returns a new SFrame with the two newly created columns, plus</span></div><div class="line"><span class="comment">   * all columns other than the stacked column. The values from those columns</span></div><div class="line"><span class="comment">   * are duplicated for all rows created from the same original row.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param column_name: string</span></div><div class="line"><span class="comment">      The column to stack. The name must come from current SFrame and must be of dict type</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param new_column_names: a list of str, optional</span></div><div class="line"><span class="comment">      Must be length of two. The two column names to stack the dict value to.</span></div><div class="line"><span class="comment">      If not given, the name is automatically generated.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param new_column_types: a list of types, optional</span></div><div class="line"><span class="comment">      Must be length of two. The type for the newly created column. If not</span></div><div class="line"><span class="comment">      given, the default to [str, int].</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param drop_na if true, missing values from dictionary will be ignored. If false,</span></div><div class="line"><span class="comment">      for missing dict value, one row will be created with the two new columns&#39; value</span></div><div class="line"><span class="comment">      being missing value</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * Retruns a new unity_sframe with stacked columns</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a50"></a><a class="code" href="classturi_1_1unity__sframe.html#a7680f8e2540042a1ecc98d7eedf497ee">stack</a>(</div><div class="line">      <span class="keyword">const</span> std::string&amp; <a class="code" href="classturi_1_1unity__sframe.html#abbfa5e9bf78162b65bb5cefe23f89ffc">column_name</a>,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; new_column_names,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;flex_type_enum&gt;&amp; new_column_types,</div><div class="line">      <span class="keywordtype">bool</span> drop_na);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   /**</span></div><div class="line"><span class="comment">    * Extracts a range of rows from an SFrame as a new SFrame.</span></div><div class="line"><span class="comment">    * This will extract rows beginning at start (inclusive) and ending at</span></div><div class="line"><span class="comment">    * end(exclusive) in steps of &quot;step&quot;.</span></div><div class="line"><span class="comment">    * step must be at least 1.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a51"></a><a class="code" href="classturi_1_1unity__sframe.html#ae176acdf81b72fae492f1abcb83fdd65">copy_range</a>(<span class="keywordtype">size_t</span> start, <span class="keywordtype">size_t</span> step, <span class="keywordtype">size_t</span> end);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new SFrame with missing values dropped.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Missing values are only searched for in the columns specified in the</span></div><div class="line"><span class="comment">   * &#39;column_names&#39;.  If this vector is empty, all columns will be considered.</span></div><div class="line"><span class="comment">   * If &#39;all&#39; is true, a row is only dropped if all specified columns contain a</span></div><div class="line"><span class="comment">   * missing value.  If false, the row is dropped if any of the specified</span></div><div class="line"><span class="comment">   * columns contain a missing value.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * If &#39;split&#39; is true, this function returns two SFrames, the first being the</span></div><div class="line"><span class="comment">   * SFrame with missing values dropped, and the second consisting of all the</span></div><div class="line"><span class="comment">   * rows removed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws if the column names are not in this SFrame, or if too many are given.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt;&gt;</div><div class="line">      <a name="a52"></a><a class="code" href="classturi_1_1unity__sframe.html#a13335d79431ec28a83f02e4ae42743d8">drop_missing_values</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;<a class="code" href="classturi_1_1unity__sframe.html#a08f9de6c5abca26cd9c3de902c956320">column_names</a>, <span class="keywordtype">bool</span> all, <span class="keywordtype">bool</span> <a name="a53"></a><a class="code" href="group__eager__algorithms.html#gab9682fbfda1c4eb780e1faafb488c3f0">split</a>);</div><div class="line"></div><div class="line">  dataframe_t to_dataframe();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> save(oarchive&amp; oarc) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> load(iarchive&amp; iarc);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> delete_on_close();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Similar to logical filter, but return both positive and negative rows.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \param logical_filter_array is an sarray of the same size, and has only</span></div><div class="line"><span class="comment">   * zeros and ones as value.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Return a list of two sframes with all positive examples goes to the first</span></div><div class="line"><span class="comment">   * one and negative rows goes to the second one.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt;&gt; <a name="a54"></a><a class="code" href="classturi_1_1unity__sframe.html#afb8f23664787da060b452e6b11959c1d">logical_filter_split</a>(</div><div class="line">    std::shared_ptr&lt;unity_sarray_base&gt; logical_filter_array);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> explore(<span class="keyword">const</span> std::string&amp; path_to_client, <span class="keyword">const</span> std::string&amp; title);</div><div class="line">  <span class="keywordtype">void</span> show(<span class="keyword">const</span> std::string&amp; path_to_client);</div><div class="line">  std::shared_ptr&lt;model_base&gt; plot(<span class="keyword">const</span> std::string&amp; path_to_client);</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Pointer to the lazy evaluator logical operator node.</span></div><div class="line"><span class="comment">   * Should never be NULL.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;query_eval::planner_node&gt; m_planner_node;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; m_column_names;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Supports \ref begin_iterator() and \ref iterator_get_next().</span></div><div class="line"><span class="comment">   * The next segment I will read. (i.e. the current segment I am reading</span></div><div class="line"><span class="comment">   * is iterator_next_segment_id - 1)</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> iterator_next_segment_id = 0;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * A copy of the current SFrame. This allows iteration, and other</span></div><div class="line"><span class="comment">   * SAarray operations to operate together safely in harmony without collisions.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::unique_ptr&lt;sframe_reader&gt; iterator_sframe_ptr;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Supports \ref begin_iterator() and \ref iterator_get_next().</span></div><div class="line"><span class="comment">   * The begin iterator of the current segment I am reading.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::unique_ptr&lt;sframe_iterator&gt; iterator_current_segment_iter;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Supports \ref begin_iterator() and \ref iterator_get_next().</span></div><div class="line"><span class="comment">   * The end iterator of the current segment I am reading.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::unique_ptr&lt;sframe_iterator&gt; iterator_current_segment_enditer;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Helper functions</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Convert column names to column indices.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * If input column_names is empty, return 0,1,2,...num_columns-1</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throw if column_names has duplication, or some column name does not exist.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt;size_t&gt; _convert_column_names_to_indices(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;<a class="code" href="classturi_1_1unity__sframe.html#a08f9de6c5abca26cd9c3de902c956320">column_names</a>);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Generate a new column name</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * New column name is in the form of X1, X2, X3 ....</span></div><div class="line"><span class="comment">   * In case of conflict, add .1, .2 until conflict is resolved.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \example</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Given current sframe column names: a, b, c</span></div><div class="line"><span class="comment">   * Next 3 generated names are: X4, X5, X6</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Given current sframe column names: X4, X5.1, X6.2</span></div><div class="line"><span class="comment">   * Next 3 generated names are: X4.1, X5, X6.1</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::string generate_next_column_name();</div><div class="line">};</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
