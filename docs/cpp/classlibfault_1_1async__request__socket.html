<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: libfault::async_request_socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classlibfault_1_1async__request__socket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibfault_1_1async__request__socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libfault::async_request_socket Class Reference<div class="ingroups"><a class="el" href="group__fault.html">Fault Resistant Communication Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fault_2sockets_2async__request__socket_8hpp_source.html">fault/sockets/async_request_socket.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4dd91d80b6873b2e47401884e5f20e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#aa4dd91d80b6873b2e47401884e5f20e1">async_request_socket</a> (void *zmq_ctx, <a class="el" href="classturi_1_1zookeeper__util_1_1key__value.html">turi::zookeeper_util::key_value</a> *keyval, std::string masterkey, std::vector&lt; std::string &gt; slavekeys, const std::string public_key=&quot;&quot;, const std::string secret_key=&quot;&quot;, const std::string server_public_key=&quot;&quot;)</td></tr>
<tr class="separator:aa4dd91d80b6873b2e47401884e5f20e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6ea005f13b2abc35fb0dbfeeba919b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#a4d6ea005f13b2abc35fb0dbfeeba919b">close</a> ()</td></tr>
<tr class="separator:a4d6ea005f13b2abc35fb0dbfeeba919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd10964622b28a2534e066a8b48ef01f"><td class="memItemLeft" align="right" valign="top">future_reply&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#afd10964622b28a2534e066a8b48ef01f">request_master</a> (<a class="el" href="classlibfault_1_1zmq__msg__vector.html">zmq_msg_vector</a> &amp;msgs, bool noreply=false)</td></tr>
<tr class="separator:afd10964622b28a2534e066a8b48ef01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6519bebae384b7fba14e441cf5b6d791"><td class="memItemLeft" align="right" valign="top">future_reply&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#a6519bebae384b7fba14e441cf5b6d791">request_any</a> (<a class="el" href="classlibfault_1_1zmq__msg__vector.html">zmq_msg_vector</a> &amp;ret, bool noreply=false)</td></tr>
<tr class="separator:a6519bebae384b7fba14e441cf5b6d791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc87b57737c08cab06dcae5621872363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#abc87b57737c08cab06dcae5621872363">keyval_change</a> (<a class="el" href="classturi_1_1zookeeper__util_1_1key__value.html">turi::zookeeper_util::key_value</a> *unused, const std::vector&lt; std::string &gt; &amp;newkeys, const std::vector&lt; std::string &gt; &amp;deletedkeys, const std::vector&lt; std::string &gt; &amp;modifiedkeys)</td></tr>
<tr class="separator:abc87b57737c08cab06dcae5621872363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45d74889e7173522495970dfb5643a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#ae45d74889e7173522495970dfb5643a4">add_to_pollset</a> (<a class="el" href="classlibfault_1_1socket__receive__pollset.html">socket_receive_pollset</a> *pollset)</td></tr>
<tr class="separator:ae45d74889e7173522495970dfb5643a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afa91add1751c05a1ae89837e168b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibfault_1_1async__request__socket.html#a2afa91add1751c05a1ae89837e168b2e">remove_from_pollset</a> ()</td></tr>
<tr class="separator:a2afa91add1751c05a1ae89837e168b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Constructs a zookeeper backed asynchronous request socket. Will automatically retry sockets. This object is multi-threaded. Calls can be made from any thread.</p>
<dl class="section note"><dt>Note</dt><dd>The design is to use DEALER sockets to communicate with the REP sockets on the other side. However, background sends are an issue because zeromq does not let me do sends and receives in seperate threads. The solution is to create 3 sockets.<ul>
<li>A DEALER socket to talk to the REP socket remotely. This can then be attached to the pollset and callbacks will then set the future.</li>
<li>An inproc PULL socket also attached to the pollset. Messages received on the PULL socket are forwarded out the DEALER socket.</li>
<li>An inproc PUSH socket to send stuff to the PULL socket.</li>
</ul>
</dd></dl>
<p>An issue is the retries are somewhat tricky to manage. So unlike the synchronous <a class="el" href="classlibfault_1_1request__socket.html">request_socket</a>, this socket does not do retries. Any failure will return a status in the future, and it is up to the client to perform the retry. </p>

<p>Definition at line <a class="el" href="fault_2sockets_2async__request__socket_8hpp_source.html#l00056">56</a> of file <a class="el" href="fault_2sockets_2async__request__socket_8hpp_source.html">async_request_socket.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa4dd91d80b6873b2e47401884e5f20e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libfault::async_request_socket::async_request_socket </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>zmq_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1zookeeper__util_1_1key__value.html">turi::zookeeper_util::key_value</a> *&#160;</td>
          <td class="paramname"><em>keyval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>masterkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>slavekeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>public_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>secret_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>server_public_key</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a request socket. The request will be sent to the current owners of the key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zmq_ctx</td><td>A zeroMQ Context </td></tr>
    <tr><td class="paramname">keyval</td><td>A zookeeper key_value object to bind to. </td></tr>
    <tr><td class="paramname">masterkey</td><td>The master object key where requests (via request_master) are sent. </td></tr>
    <tr><td class="paramname">slavekeys</td><td>The slave object keys where requests (via request_any) are sent.</td></tr>
  </table>
  </dd>
</dl>
<p>If keyval is NULL, masterkey and slavekeys must directly refer to ZeroMQ endpoints. ex: tcp://.... , in which case this socket behaves like a simple messaging wrapper around ZeroMQ which provides asynchronous messaging capabilities. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae45d74889e7173522495970dfb5643a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libfault::async_request_socket::add_to_pollset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibfault_1_1socket__receive__pollset.html">socket_receive_pollset</a> *&#160;</td>
          <td class="paramname"><em>pollset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers this socket with the pollset This socket should only registered with one pollset. </p>

</div>
</div>
<a class="anchor" id="a4d6ea005f13b2abc35fb0dbfeeba919b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libfault::async_request_socket::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes this socket. Once closed, the socket cannot be used again. </p>

</div>
</div>
<a class="anchor" id="abc87b57737c08cab06dcae5621872363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libfault::async_request_socket::keyval_change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1zookeeper__util_1_1key__value.html">turi::zookeeper_util::key_value</a> *&#160;</td>
          <td class="paramname"><em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>newkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>deletedkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>modifiedkeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signals that some sets of keys have changed and we should refresh some values. May be called from a different thread </p>

</div>
</div>
<a class="anchor" id="a2afa91add1751c05a1ae89837e168b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libfault::async_request_socket::remove_from_pollset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters this socket with the pollset. Also destroys any pending futures </p>

</div>
</div>
<a class="anchor" id="a6519bebae384b7fba14e441cf5b6d791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future_reply libfault::async_request_socket::request_any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibfault_1_1zmq__msg__vector.html">zmq_msg_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noreply</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns 0 on success. Returns a future to a message_reply pointer containing the reply message as well as a status which may contain an error. The message_reply pointer must be freed by the user when done.</p>
<p>Possible errors are:</p>
<ul>
<li><b>EHOSTUNREACH</b> All target machines are currently unreachable. This could be because all nodes registered with the masterkey or slave keys are down, or not responding.</li>
<li><b>EPIPE</b> The message was sent, but the connection failed while waiting for a response. It is unknown if the message was actually received on the target machines </li>
</ul>

</div>
</div>
<a class="anchor" id="afd10964622b28a2534e066a8b48ef01f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">future_reply libfault::async_request_socket::request_master </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibfault_1_1zmq__msg__vector.html">zmq_msg_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noreply</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a request to the object registered to the master key. Returns a future to a message_reply pointer containing the reply message as well as a status which may contain an error. The message_reply pointer must be freed by the user when done.</p>
<p>Possible errors are:</p>
<ul>
<li><b>EHOSTUNREACH</b> Target machine is currently unreachable. This could be because the node registered with the master key is down, or not responding.</li>
<li><b>EPIPE</b> The message was sent, but the connection failed while waiting for a response. It is unknown if the message was actually received on the master machine. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>fault/sockets/<a class="el" href="fault_2sockets_2async__request__socket_8hpp_source.html">async_request_socket.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>libfault</b></li><li class="navelem"><a class="el" href="classlibfault_1_1async__request__socket.html">async_request_socket</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
