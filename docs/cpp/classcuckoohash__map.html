<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: cuckoohash_map&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcuckoohash__map.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcuckoohash__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cuckoohash_map&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__util.html">Utility Classes and Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="cuckoohash__map_8hh_source.html">util/cuckoohash_map.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map_1_1reference.html">reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a024936e091e714f4ffc2484e0dc3daea"><td class="memItemLeft" align="right" valign="top"><a id="a024936e091e714f4ffc2484e0dc3daea"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a></td></tr>
<tr class="memdesc:a024936e091e714f4ffc2484e0dc3daea"><td class="mdescLeft">&#160;</td><td class="mdescRight">key_type is the type of keys. <br /></td></tr>
<tr class="separator:a024936e091e714f4ffc2484e0dc3daea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc92197a4aa4a06d94fecaebb463adfb"><td class="memItemLeft" align="right" valign="top"><a id="acc92197a4aa4a06d94fecaebb463adfb"></a>
typedef std::pair&lt; const Key, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#acc92197a4aa4a06d94fecaebb463adfb">value_type</a></td></tr>
<tr class="memdesc:acc92197a4aa4a06d94fecaebb463adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">value_type is the type of key-value pairs. <br /></td></tr>
<tr class="separator:acc92197a4aa4a06d94fecaebb463adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84358980ded175e7092a7570eded618d"><td class="memItemLeft" align="right" valign="top"><a id="a84358980ded175e7092a7570eded618d"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a></td></tr>
<tr class="memdesc:a84358980ded175e7092a7570eded618d"><td class="mdescLeft">&#160;</td><td class="mdescRight">mapped_type is the type of values. <br /></td></tr>
<tr class="separator:a84358980ded175e7092a7570eded618d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1df8e5fab6b04e470530f16b0a8c1f"><td class="memItemLeft" align="right" valign="top"><a id="a2f1df8e5fab6b04e470530f16b0a8c1f"></a>
typedef Hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a2f1df8e5fab6b04e470530f16b0a8c1f">hasher</a></td></tr>
<tr class="memdesc:a2f1df8e5fab6b04e470530f16b0a8c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">hasher is the type of the hash function. <br /></td></tr>
<tr class="separator:a2f1df8e5fab6b04e470530f16b0a8c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9dd2fbde5caff0779f7f53227bbc68"><td class="memItemLeft" align="right" valign="top"><a id="abe9dd2fbde5caff0779f7f53227bbc68"></a>
typedef Pred&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#abe9dd2fbde5caff0779f7f53227bbc68">key_equal</a></td></tr>
<tr class="memdesc:abe9dd2fbde5caff0779f7f53227bbc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">key_equal is the type of the equality predicate. <br /></td></tr>
<tr class="separator:abe9dd2fbde5caff0779f7f53227bbc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0347edca7eb24e46f7ee7685d0ba8540"><td class="memItemLeft" align="right" valign="top"><a id="a0347edca7eb24e46f7ee7685d0ba8540"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a0347edca7eb24e46f7ee7685d0ba8540">allocator_type</a></td></tr>
<tr class="memdesc:a0347edca7eb24e46f7ee7685d0ba8540"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator_type is the type of the allocator <br /></td></tr>
<tr class="separator:a0347edca7eb24e46f7ee7685d0ba8540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b1ea53e77761d3c7d3547a45d5fbdbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a7b1ea53e77761d3c7d3547a45d5fbdbf">cuckoohash_map</a> (size_t n=DEFAULT_SIZE)</td></tr>
<tr class="separator:a7b1ea53e77761d3c7d3547a45d5fbdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dfcb36f7e63347cd1e66cec6f8de92"><td class="memItemLeft" align="right" valign="top"><a id="a04dfcb36f7e63347cd1e66cec6f8de92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a04dfcb36f7e63347cd1e66cec6f8de92">~cuckoohash_map</a> ()</td></tr>
<tr class="memdesc:a04dfcb36f7e63347cd1e66cec6f8de92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor explicitly deletes the current table info. <br /></td></tr>
<tr class="separator:a04dfcb36f7e63347cd1e66cec6f8de92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064323d48b43d36dc9ddd56e33a27f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a064323d48b43d36dc9ddd56e33a27f55">clear</a> ()</td></tr>
<tr class="separator:a064323d48b43d36dc9ddd56e33a27f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dda5f72e2b99488270b9bb2e87dd34"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#aa8dda5f72e2b99488270b9bb2e87dd34">size</a> () const</td></tr>
<tr class="separator:aa8dda5f72e2b99488270b9bb2e87dd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab068b5eb815244b010d11d7d63489d"><td class="memItemLeft" align="right" valign="top"><a id="a0ab068b5eb815244b010d11d7d63489d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a0ab068b5eb815244b010d11d7d63489d">empty</a> () const</td></tr>
<tr class="memdesc:a0ab068b5eb815244b010d11d7d63489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty returns true if the table is empty. <br /></td></tr>
<tr class="separator:a0ab068b5eb815244b010d11d7d63489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c293a1e9ca0ee0c41149b0d18dd9327"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a2c293a1e9ca0ee0c41149b0d18dd9327">hashpower</a> () const</td></tr>
<tr class="separator:a2c293a1e9ca0ee0c41149b0d18dd9327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501b7093c3eccbb96a564495884b21f8"><td class="memItemLeft" align="right" valign="top"><a id="a501b7093c3eccbb96a564495884b21f8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a501b7093c3eccbb96a564495884b21f8">bucket_count</a> () const</td></tr>
<tr class="memdesc:a501b7093c3eccbb96a564495884b21f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket_count returns the number of buckets in the table. <br /></td></tr>
<tr class="separator:a501b7093c3eccbb96a564495884b21f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abb4cd2fa8feecb8612a9d3a4de52c4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a1abb4cd2fa8feecb8612a9d3a4de52c4">load_factor</a> () const</td></tr>
<tr class="separator:a1abb4cd2fa8feecb8612a9d3a4de52c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac110b108ff582ff7096afe65a389fe4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#aac110b108ff582ff7096afe65a389fe4">find</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key, <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp;val) const</td></tr>
<tr class="separator:aac110b108ff582ff7096afe65a389fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c8818fac9c8a9feedee5b9f73e21f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a17c8818fac9c8a9feedee5b9f73e21f9">find</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key) const</td></tr>
<tr class="separator:a17c8818fac9c8a9feedee5b9f73e21f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3e27c1737f836af2117f1e83b388aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a4e3e27c1737f836af2117f1e83b388aa">contains</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key) const</td></tr>
<tr class="separator:a4e3e27c1737f836af2117f1e83b388aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb58452f2bba67f4adae57ce52983c"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a22cb58452f2bba67f4adae57ce52983c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; V, const <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp; &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a22cb58452f2bba67f4adae57ce52983c">insert</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key, V val)</td></tr>
<tr class="separator:a22cb58452f2bba67f4adae57ce52983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50918457d9ae4ec472ada8c393e7b2c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a50918457d9ae4ec472ada8c393e7b2c7">erase</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key)</td></tr>
<tr class="separator:a50918457d9ae4ec472ada8c393e7b2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dc671d577f15de0b74a4fe96bed7f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a63dc671d577f15de0b74a4fe96bed7f0">update</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key, const <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp;val)</td></tr>
<tr class="separator:a63dc671d577f15de0b74a4fe96bed7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51fbebea414717c44f1bf89b0a407b7"><td class="memTemplParams" colspan="2">template&lt;typename Updater &gt; </td></tr>
<tr class="memitem:ad51fbebea414717c44f1bf89b0a407b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#ad51fbebea414717c44f1bf89b0a407b7">update_fn</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key, Updater fn)</td></tr>
<tr class="separator:ad51fbebea414717c44f1bf89b0a407b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dbdb55a853e93cb4934f2b7b781610"><td class="memTemplParams" colspan="2">template&lt;typename Updater &gt; </td></tr>
<tr class="memitem:a26dbdb55a853e93cb4934f2b7b781610"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a26dbdb55a853e93cb4934f2b7b781610">upsert</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key, Updater fn, const <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp;val)</td></tr>
<tr class="separator:a26dbdb55a853e93cb4934f2b7b781610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6168d1dc8dcfd191e3479995dc7f1a6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a6168d1dc8dcfd191e3479995dc7f1a6c">rehash</a> (size_t n)</td></tr>
<tr class="separator:a6168d1dc8dcfd191e3479995dc7f1a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a3dae71b07168305e4dff1b6bc17dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#ad0a3dae71b07168305e4dff1b6bc17dd">reserve</a> (size_t n)</td></tr>
<tr class="separator:ad0a3dae71b07168305e4dff1b6bc17dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ab26e6b6dffe554f1f517fed7b1288"><td class="memItemLeft" align="right" valign="top"><a id="ac7ab26e6b6dffe554f1f517fed7b1288"></a>
<a class="el" href="classcuckoohash__map.html#a2f1df8e5fab6b04e470530f16b0a8c1f">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#ac7ab26e6b6dffe554f1f517fed7b1288">hash_function</a> () const</td></tr>
<tr class="memdesc:ac7ab26e6b6dffe554f1f517fed7b1288"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash_function returns the hash function object used by the table. <br /></td></tr>
<tr class="separator:ac7ab26e6b6dffe554f1f517fed7b1288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d15ecb8e6db27639950889d4c37a9ac"><td class="memItemLeft" align="right" valign="top"><a id="a3d15ecb8e6db27639950889d4c37a9ac"></a>
<a class="el" href="classcuckoohash__map.html#abe9dd2fbde5caff0779f7f53227bbc68">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a3d15ecb8e6db27639950889d4c37a9ac">key_eq</a> () const</td></tr>
<tr class="memdesc:a3d15ecb8e6db27639950889d4c37a9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">key_eq returns the equality predicate object used by the table. <br /></td></tr>
<tr class="separator:a3d15ecb8e6db27639950889d4c37a9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aafc82ed6a47c8a75bcd06115a4f740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcuckoohash__map_1_1reference.html">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a5aafc82ed6a47c8a75bcd06115a4f740">operator[]</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key)</td></tr>
<tr class="separator:a5aafc82ed6a47c8a75bcd06115a4f740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ca49c702981d89fd0f10043666ebeb"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#ae4ca49c702981d89fd0f10043666ebeb">operator[]</a> (const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;key) const</td></tr>
<tr class="separator:ae4ca49c702981d89fd0f10043666ebeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e051c9c429b65a1039c60fe651d17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#ae9e051c9c429b65a1039c60fe651d17e">cbegin</a> () const</td></tr>
<tr class="separator:ae9e051c9c429b65a1039c60fe651d17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5eaa36c7c2ff230b6e0722aba7b3ff"><td class="memItemLeft" align="right" valign="top"><a id="acc5eaa36c7c2ff230b6e0722aba7b3ff"></a>
<a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#acc5eaa36c7c2ff230b6e0722aba7b3ff">cend</a> () const</td></tr>
<tr class="memdesc:acc5eaa36c7c2ff230b6e0722aba7b3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">cend returns a <a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a> set past the end of the table. <br /></td></tr>
<tr class="separator:acc5eaa36c7c2ff230b6e0722aba7b3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e69093b5893cc78b11ea81bc55f841"><td class="memItemLeft" align="right" valign="top"><a id="ae6e69093b5893cc78b11ea81bc55f841"></a>
<a class="el" href="classcuckoohash__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#ae6e69093b5893cc78b11ea81bc55f841">begin</a> ()</td></tr>
<tr class="memdesc:ae6e69093b5893cc78b11ea81bc55f841"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin returns an iterator to the first filled slot in the table. <br /></td></tr>
<tr class="separator:ae6e69093b5893cc78b11ea81bc55f841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377606430b3ec073553ddf94ab29bfdf"><td class="memItemLeft" align="right" valign="top"><a id="a377606430b3ec073553ddf94ab29bfdf"></a>
<a class="el" href="classcuckoohash__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a377606430b3ec073553ddf94ab29bfdf">end</a> ()</td></tr>
<tr class="memdesc:a377606430b3ec073553ddf94ab29bfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">end returns an iterator set past the end of the table. <br /></td></tr>
<tr class="separator:a377606430b3ec073553ddf94ab29bfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b93e341bf982629dc5ea186bc12b3b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcuckoohash__map.html#acc92197a4aa4a06d94fecaebb463adfb">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcuckoohash__map.html#a91b93e341bf982629dc5ea186bc12b3b">snapshot_table</a> () const</td></tr>
<tr class="separator:a91b93e341bf982629dc5ea186bc12b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt;<br />
class cuckoohash_map&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;</h3>

<p>This is a copy of libcuckoo from <a href="https://github.com/efficient/libcuckoo/">https://github.com/efficient/libcuckoo/</a> Apache Licensed. </p><pre class="fragment">* Copyright (C) 2013, Carnegie Mellon University and Intel Corporation
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*  ---------------------------
*
*  The third-party libraries have their own licenses, as detailed in their source
*  files.
* </pre> 
<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00062">62</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b1ea53e77761d3c7d3547a45d5fbdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1ea53e77761d3c7d3547a45d5fbdbf">&#9670;&nbsp;</a></span>cuckoohash_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::<a class="el" href="classcuckoohash__map.html">cuckoohash_map</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>DEFAULT_SIZE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor creates a new hash table with enough space for <code>n</code> elements. If the constructor fails, it will throw an exception. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00443">443</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9e051c9c429b65a1039c60fe651d17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e051c9c429b65a1039c60fe651d17e">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>cbegin returns a <a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a> to the first filled slot in the table. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l02136">2136</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a064323d48b43d36dc9ddd56e33a27f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064323d48b43d36dc9ddd56e33a27f55">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>clear removes all the elements in the hash table, calling their destructors. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00466">466</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a4e3e27c1737f836af2117f1e83b388aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3e27c1737f836af2117f1e83b388aa">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>contains searches through the table for <code>key</code>, and returns true if it finds it in the table, and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00551">551</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a50918457d9ae4ec472ada8c393e7b2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50918457d9ae4ec472ada8c393e7b2c7">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>erase removes <code>key</code> and it's associated value from the table, calling their destructors. If <code>key</code> is not there, it returns false, otherwise it returns true. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00588">588</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="aac110b108ff582ff7096afe65a389fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac110b108ff582ff7096afe65a389fe4">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>find searches through the table for <code>key</code>, and stores the associated value it finds in <code>val</code>. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00522">522</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a17c8818fac9c8a9feedee5b9f73e21f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c8818fac9c8a9feedee5b9f73e21f9">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version of find does the same thing as the two-argument version, except it returns the value it finds, throwing an <code>std::out_of_range</code> exception if the key isn't in the table. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00539">539</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a2c293a1e9ca0ee0c41149b0d18dd9327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c293a1e9ca0ee0c41149b0d18dd9327">&#9670;&nbsp;</a></span>hashpower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::hashpower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>hashpower returns the hashpower of the table, which is log<sub>2</sub>(the number of buckets). </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00493">493</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a22cb58452f2bba67f4adae57ce52983c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb58452f2bba67f4adae57ce52983c">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;V, const <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a>&amp;&gt;::value, bool&gt;::type <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>insert puts the given key-value pair into the table. It first checks that <code>key</code> isn't already in the table, since the table doesn't support duplicate keys. If the table is out of space, insert will automatically expand until it can succeed. Note that expansion can throw an exception, which insert will propagate. If <code>key</code> is already in the table, it returns false, otherwise it returns true. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00573">573</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a1abb4cd2fa8feecb8612a9d3a4de52c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abb4cd2fa8feecb8612a9d3a4de52c4">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>load_factor returns the ratio of the number of items in the table to the total number of available slots in the table. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00512">512</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a5aafc82ed6a47c8a75bcd06115a4f740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aafc82ed6a47c8a75bcd06115a4f740">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcuckoohash__map_1_1reference.html">reference</a> <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classcuckoohash__map_1_1reference.html">reference</a> to the mapped value stored at the given key. Note that the reference behaves somewhat differently from an STL map reference (see the <a class="el" href="classcuckoohash__map_1_1reference.html">reference</a> documentation for details). </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00725">725</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="ae4ca49c702981d89fd0f10043666ebeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ca49c702981d89fd0f10043666ebeb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const_reference to the mapped value stored at the given key. This is equivalent to running the overloaded <a class="el" href="classcuckoohash__map.html#aac110b108ff582ff7096afe65a389fe4">find</a> function with no value parameter. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00732">732</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a6168d1dc8dcfd191e3479995dc7f1a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6168d1dc8dcfd191e3479995dc7f1a6c">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>rehash will size the table using a hashpower of <code>n</code>. Note that the number of buckets in the table will be 2<sup><code>n</sup></code> after expansion, so the table will have 2<sup><code>n</sup></code> &times; SLOT_PER_BUCKET slots to store items in. If <code>n</code> is not larger than the current hashpower, then it decreases the hashpower to either <code>n</code> or the smallest power that can hold all the elements currently in the table. It returns true if the table expansion succeeded, and false otherwise. rehash can throw an exception if the expansion fails to allocate enough memory for the larger table. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00679">679</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="ad0a3dae71b07168305e4dff1b6bc17dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a3dae71b07168305e4dff1b6bc17dd">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>reserve will size the table to have enough slots for at least <code>n</code> elements. If the table can already hold that many elements, the function will shrink the table to the smallest hashpower that can hold the maximum of <code>n</code> and the current table size. Otherwise, the function will expand the table to a hashpower sufficient to hold <code>n</code> elements. It will return true if there was an expansion, and false otherwise. reserve can throw an exception if the expansion fails to allocate enough memory for the larger table. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00699">699</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="aa8dda5f72e2b99488270b9bb2e87dd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dda5f72e2b99488270b9bb2e87dd34">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>size returns the number of items currently in the hash table. Since it doesn't lock the table, elements can be inserted during the computation, so the result may not necessarily be exact. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00478">478</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a91b93e341bf982629dc5ea186bc12b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b93e341bf982629dc5ea186bc12b3b">&#9670;&nbsp;</a></span>snapshot_table()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcuckoohash__map.html#acc92197a4aa4a06d94fecaebb463adfb">value_type</a>&gt; <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::snapshot_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>snapshot_table allocates a vector and, using a <a class="el" href="classcuckoohash__map_1_1const__iterator.html">const_iterator</a> stores all the elements currently in the table. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l02157">2157</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a63dc671d577f15de0b74a4fe96bed7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dc671d577f15de0b74a4fe96bed7f0">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>update changes the value associated with <code>key</code> to <code>val</code>. If <code>key</code> is not there, it returns false, otherwise it returns true. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00605">605</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="ad51fbebea414717c44f1bf89b0a407b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51fbebea414717c44f1bf89b0a407b7">&#9670;&nbsp;</a></span>update_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename Updater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::update_fn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Updater&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>update_fn changes the value associated with <code>key</code> with the function <code>fn</code>. <code>fn</code> will be passed one argument of type <code>mapped_type&amp;</code> and can modify the argument as desired, returning nothing. If <code>key</code> is not there, it returns false, otherwise it returns true. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00623">623</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<a id="a26dbdb55a853e93cb4934f2b7b781610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dbdb55a853e93cb4934f2b7b781610">&#9670;&nbsp;</a></span>upsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key, class T, class Hash = std::hash&lt;Key&gt;, class Pred = std::equal_to&lt;Key&gt;, class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;, size_t SLOT_PER_BUCKET = DEFAULT_SLOT_PER_BUCKET&gt; </div>
<div class="memtemplate">
template&lt;typename Updater &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcuckoohash__map.html">cuckoohash_map</a>&lt; Key, T, Hash, Pred, Alloc, SLOT_PER_BUCKET &gt;::upsert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a024936e091e714f4ffc2484e0dc3daea">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Updater&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcuckoohash__map.html#a84358980ded175e7092a7570eded618d">mapped_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>upsert is a combination of update_fn and insert. It first tries updating the value associated with <code>key</code> using <code>fn</code>. If <code>key</code> is not in the table, then it runs an insert with <code>key</code> and <code>val</code>. It will always succeed, since if the update fails and the insert finds the key already inserted, it can retry the update. </p>

<p class="definition">Definition at line <a class="el" href="cuckoohash__map_8hh_source.html#l00642">642</a> of file <a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>util/<a class="el" href="cuckoohash__map_8hh_source.html">cuckoohash_map.hh</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classcuckoohash__map.html">cuckoohash_map</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
