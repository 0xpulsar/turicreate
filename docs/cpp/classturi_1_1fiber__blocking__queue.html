<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::fiber_blocking_queue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1fiber__blocking__queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1fiber__blocking__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::fiber_blocking_queue&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__util.html">Utility Classes and Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements a blocking queue useful for producer/consumer models. Similar to the <a class="el" href="classturi_1_1blocking__queue.html">blocking_queue</a>, but requires all threads waiting on the queue to be fibers. Also only supports the basic wait on dequeue operation, and not the other timed_wait, or wait_until_empty operations supported by the <a class="el" href="classturi_1_1blocking__queue.html">blocking_queue</a>.  
 <a href="classturi_1_1fiber__blocking__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fiber__blocking__queue_8hpp_source.html">util/fiber_blocking_queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a60841124b4a5908c97ac364a7d873003"><td class="memItemLeft" align="right" valign="top"><a id="a60841124b4a5908c97ac364a7d873003"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#a60841124b4a5908c97ac364a7d873003">fiber_blocking_queue</a> ()</td></tr>
<tr class="memdesc:a60841124b4a5908c97ac364a7d873003"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a blocking queue <br /></td></tr>
<tr class="separator:a60841124b4a5908c97ac364a7d873003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae073f2ca281719e99afdcb013e20b5ba"><td class="memItemLeft" align="right" valign="top"><a id="ae073f2ca281719e99afdcb013e20b5ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#ae073f2ca281719e99afdcb013e20b5ba">enqueue</a> (const T &amp;elem, bool wake_consumer=true)</td></tr>
<tr class="memdesc:ae073f2ca281719e99afdcb013e20b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the blocking queue. <br /></td></tr>
<tr class="separator:ae073f2ca281719e99afdcb013e20b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdac75f630889b0f763d55d43711288d"><td class="memItemLeft" align="right" valign="top"><a id="acdac75f630889b0f763d55d43711288d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#acdac75f630889b0f763d55d43711288d">enqueue_to_head</a> (const T &amp;elem)</td></tr>
<tr class="memdesc:acdac75f630889b0f763d55d43711288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the blocking queue. <br /></td></tr>
<tr class="separator:acdac75f630889b0f763d55d43711288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87f17ecd298160c548f14d9a46a18a8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; T, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#aa87f17ecd298160c548f14d9a46a18a8">dequeue</a> ()</td></tr>
<tr class="separator:aa87f17ecd298160c548f14d9a46a18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa93ade9e4364bfc413cce5c0165a0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; T, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#a02aa93ade9e4364bfc413cce5c0165a0">try_dequeue</a> ()</td></tr>
<tr class="separator:a02aa93ade9e4364bfc413cce5c0165a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9abba04c23813384e1d49bb5e4f3683"><td class="memItemLeft" align="right" valign="top"><a id="aa9abba04c23813384e1d49bb5e4f3683"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#aa9abba04c23813384e1d49bb5e4f3683">empty</a> ()</td></tr>
<tr class="memdesc:aa9abba04c23813384e1d49bb5e4f3683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue is empty. <br /></td></tr>
<tr class="separator:aa9abba04c23813384e1d49bb5e4f3683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ce10889e1578edf4b5c3f2be19493d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#ab1ce10889e1578edf4b5c3f2be19493d">stop_blocking</a> ()</td></tr>
<tr class="separator:ab1ce10889e1578edf4b5c3f2be19493d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f2c3019a8db0daddd367be4dad8ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#a257f2c3019a8db0daddd367be4dad8ab">start_blocking</a> ()</td></tr>
<tr class="separator:a257f2c3019a8db0daddd367be4dad8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff20fd8a61be7312237ff4fcf6a0f49"><td class="memItemLeft" align="right" valign="top"><a id="a4ff20fd8a61be7312237ff4fcf6a0f49"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#a4ff20fd8a61be7312237ff4fcf6a0f49">size</a> ()</td></tr>
<tr class="memdesc:a4ff20fd8a61be7312237ff4fcf6a0f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current size of the queue <br /></td></tr>
<tr class="separator:a4ff20fd8a61be7312237ff4fcf6a0f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32be6924a78bf3413a852608b9bad2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fiber__blocking__queue.html#a32be6924a78bf3413a852608b9bad2ad">broadcast</a> ()</td></tr>
<tr class="separator:a32be6924a78bf3413a852608b9bad2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class turi::fiber_blocking_queue&lt; T &gt;</h3>

<p>Implements a blocking queue useful for producer/consumer models. Similar to the <a class="el" href="classturi_1_1blocking__queue.html">blocking_queue</a>, but requires all threads waiting on the queue to be fibers. Also only supports the basic wait on dequeue operation, and not the other timed_wait, or wait_until_empty operations supported by the <a class="el" href="classturi_1_1blocking__queue.html">blocking_queue</a>. </p>

<p class="definition">Definition at line <a class="el" href="fiber__blocking__queue_8hpp_source.html#l00029">29</a> of file <a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a32be6924a78bf3413a852608b9bad2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32be6924a78bf3413a852608b9bad2ad">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1fiber__blocking__queue.html">turi::fiber_blocking_queue</a>&lt; T &gt;::broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Causes any threads currently blocking on a dequeue to wake up and evaluate the state of the queue. If the queue is empty, the threads will return back to sleep immediately. If the queue is destroyed through stop_blocking, all threads will return. </p>

<p class="definition">Definition at line <a class="el" href="fiber__blocking__queue_8hpp_source.html#l00218">218</a> of file <a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a>.</p>

</div>
</div>
<a id="aa87f17ecd298160c548f14d9a46a18a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87f17ecd298160c548f14d9a46a18a8">&#9670;&nbsp;</a></span>dequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T, bool&gt; <a class="el" href="classturi_1_1fiber__blocking__queue.html">turi::fiber_blocking_queue</a>&lt; T &gt;::dequeue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks until an element is available in the queue or until <a class="el" href="classturi_1_1fiber__blocking__queue.html#ab1ce10889e1578edf4b5c3f2be19493d">stop_blocking()</a> is called. The return value is a pair of &lt;T value, bool success&gt; If "success" if set, then "value" is valid and is an element popped from the queue. If "success" is false, <a class="el" href="classturi_1_1fiber__blocking__queue.html#ab1ce10889e1578edf4b5c3f2be19493d">stop_blocking()</a> was called and the queue has been destroyed. </p>

<p class="definition">Definition at line <a class="el" href="fiber__blocking__queue_8hpp_source.html#l00131">131</a> of file <a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a>.</p>

</div>
</div>
<a id="a257f2c3019a8db0daddd367be4dad8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f2c3019a8db0daddd367be4dad8ab">&#9670;&nbsp;</a></span>start_blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1fiber__blocking__queue.html">turi::fiber_blocking_queue</a>&lt; T &gt;::start_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes operation of the <a class="el" href="classturi_1_1fiber__blocking__queue.html" title="Implements a blocking queue useful for producer/consumer models. Similar to the blocking_queue, but requires all threads waiting on the queue to be fibers. Also only supports the basic wait on dequeue operation, and not the other timed_wait, or wait_until_empty operations supported by the blocking_queue. ">fiber_blocking_queue</a>. Future calls to dequeue will proceed as normal. </p>

<p class="definition">Definition at line <a class="el" href="fiber__blocking__queue_8hpp_source.html#l00200">200</a> of file <a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a>.</p>

</div>
</div>
<a id="ab1ce10889e1578edf4b5c3f2be19493d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ce10889e1578edf4b5c3f2be19493d">&#9670;&nbsp;</a></span>stop_blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1fiber__blocking__queue.html">turi::fiber_blocking_queue</a>&lt; T &gt;::stop_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wakes up all threads waiting on the queue whether or not an element is available. Once this function is called, all existing and future dequeue operations will return with failure. Note that there could be elements remaining in the queue after <a class="el" href="classturi_1_1fiber__blocking__queue.html#ab1ce10889e1578edf4b5c3f2be19493d">stop_blocking()</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="fiber__blocking__queue_8hpp_source.html#l00189">189</a> of file <a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a>.</p>

</div>
</div>
<a id="a02aa93ade9e4364bfc413cce5c0165a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa93ade9e4364bfc413cce5c0165a0">&#9670;&nbsp;</a></span>try_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T, bool&gt; <a class="el" href="classturi_1_1fiber__blocking__queue.html">turi::fiber_blocking_queue</a>&lt; T &gt;::try_dequeue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an element if the queue has an entry. returns [item, false] otherwise. </p>

<p class="definition">Definition at line <a class="el" href="fiber__blocking__queue_8hpp_source.html#l00157">157</a> of file <a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>util/<a class="el" href="fiber__blocking__queue_8hpp_source.html">fiber_blocking_queue.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1fiber__blocking__queue.html">fiber_blocking_queue</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
