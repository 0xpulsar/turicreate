// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DataStructures.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "DataStructures.pb.h"

#include <algorithm>

#include <protobuf/stubs/common.h>
#include <protobuf/stubs/port.h>
#include <protobuf/stubs/once.h>
#include <protobuf/io/coded_stream.h>
#include <protobuf/wire_format_lite_inl.h>
#include <protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CoreML {
namespace Specification {

void protobuf_ShutdownFile_DataStructures_2eproto() {
  StringToInt64Map_default_instance_.Shutdown();
  Int64ToStringMap_default_instance_.Shutdown();
  StringToDoubleMap_default_instance_.Shutdown();
  Int64ToDoubleMap_default_instance_.Shutdown();
  StringVector_default_instance_.Shutdown();
  Int64Vector_default_instance_.Shutdown();
  DoubleVector_default_instance_.Shutdown();
}

void protobuf_InitDefaults_DataStructures_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::CoreML::Specification::protobuf_InitDefaults_FeatureTypes_2eproto();
  ::google::protobuf::internal::GetEmptyString();
  StringToInt64Map_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  Int64ToStringMap_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  ::google::protobuf::internal::GetEmptyString();
  StringToDoubleMap_default_instance_.DefaultConstruct();
  Int64ToDoubleMap_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  StringVector_default_instance_.DefaultConstruct();
  Int64Vector_default_instance_.DefaultConstruct();
  DoubleVector_default_instance_.DefaultConstruct();
  StringToInt64Map_default_instance_.get_mutable()->InitAsDefaultInstance();
  Int64ToStringMap_default_instance_.get_mutable()->InitAsDefaultInstance();
  StringToDoubleMap_default_instance_.get_mutable()->InitAsDefaultInstance();
  Int64ToDoubleMap_default_instance_.get_mutable()->InitAsDefaultInstance();
  StringVector_default_instance_.get_mutable()->InitAsDefaultInstance();
  Int64Vector_default_instance_.get_mutable()->InitAsDefaultInstance();
  DoubleVector_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_DataStructures_2eproto_once_);
void protobuf_InitDefaults_DataStructures_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_DataStructures_2eproto_once_,
                 &protobuf_InitDefaults_DataStructures_2eproto_impl);
}
void protobuf_AddDesc_DataStructures_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_DataStructures_2eproto();
  ::CoreML::Specification::protobuf_AddDesc_FeatureTypes_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_DataStructures_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_DataStructures_2eproto_once_);
void protobuf_AddDesc_DataStructures_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_DataStructures_2eproto_once_,
                 &protobuf_AddDesc_DataStructures_2eproto_impl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_DataStructures_2eproto {
  StaticDescriptorInitializer_DataStructures_2eproto() {
    protobuf_AddDesc_DataStructures_2eproto();
  }
} static_descriptor_initializer_DataStructures_2eproto_;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringToInt64Map::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringToInt64Map::StringToInt64Map()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringToInt64Map)
}

void StringToInt64Map::InitAsDefaultInstance() {
}

StringToInt64Map::StringToInt64Map(const StringToInt64Map& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringToInt64Map)
}

void StringToInt64Map::SharedCtor() {
  _cached_size_ = 0;
}

StringToInt64Map::~StringToInt64Map() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringToInt64Map)
  SharedDtor();
}

void StringToInt64Map::SharedDtor() {
}

void StringToInt64Map::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringToInt64Map& StringToInt64Map::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<StringToInt64Map> StringToInt64Map_default_instance_;

StringToInt64Map* StringToInt64Map::New(::google::protobuf::Arena* arena) const {
  StringToInt64Map* n = new StringToInt64Map;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringToInt64Map::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringToInt64Map)
  map_.Clear();
}

bool StringToInt64Map::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringToInt64Map)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, int64> map = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_map:
          StringToInt64Map_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              ::std::string, ::google::protobuf::int64,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
              0 >,
            ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.StringToInt64Map.MapEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_map;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringToInt64Map)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringToInt64Map)
  return false;
#undef DO_
}

void StringToInt64Map::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringToInt64Map)
  // map<string, int64> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.StringToInt64Map.MapEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<StringToInt64Map_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<StringToInt64Map_MapEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringToInt64Map)
}

size_t StringToInt64Map::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringToInt64Map)
  size_t total_size = 0;

  // map<string, int64> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<StringToInt64Map_MapEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringToInt64Map::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringToInt64Map*>(&from));
}

void StringToInt64Map::MergeFrom(const StringToInt64Map& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringToInt64Map)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void StringToInt64Map::UnsafeMergeFrom(const StringToInt64Map& from) {
  GOOGLE_DCHECK(&from != this);
  map_.MergeFrom(from.map_);
}

void StringToInt64Map::CopyFrom(const StringToInt64Map& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringToInt64Map)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool StringToInt64Map::IsInitialized() const {

  return true;
}

void StringToInt64Map::Swap(StringToInt64Map* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringToInt64Map::InternalSwap(StringToInt64Map* other) {
  map_.Swap(&other->map_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringToInt64Map::GetTypeName() const {
  return "CoreML.Specification.StringToInt64Map";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringToInt64Map

// map<string, int64> map = 1;
int StringToInt64Map::map_size() const {
  return map_.size();
}
void StringToInt64Map::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >&
StringToInt64Map::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.StringToInt64Map.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::google::protobuf::int64 >*
StringToInt64Map::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.StringToInt64Map.map)
  return map_.MutableMap();
}

inline const StringToInt64Map* StringToInt64Map::internal_default_instance() {
  return &StringToInt64Map_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64ToStringMap::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64ToStringMap::Int64ToStringMap()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64ToStringMap)
}

void Int64ToStringMap::InitAsDefaultInstance() {
}

Int64ToStringMap::Int64ToStringMap(const Int64ToStringMap& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64ToStringMap)
}

void Int64ToStringMap::SharedCtor() {
  _cached_size_ = 0;
}

Int64ToStringMap::~Int64ToStringMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64ToStringMap)
  SharedDtor();
}

void Int64ToStringMap::SharedDtor() {
}

void Int64ToStringMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64ToStringMap& Int64ToStringMap::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Int64ToStringMap> Int64ToStringMap_default_instance_;

Int64ToStringMap* Int64ToStringMap::New(::google::protobuf::Arena* arena) const {
  Int64ToStringMap* n = new Int64ToStringMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64ToStringMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64ToStringMap)
  map_.Clear();
}

bool Int64ToStringMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64ToStringMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<int64, string> map = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_map:
          Int64ToStringMap_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              ::google::protobuf::int64, ::std::string,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              0 >,
            ::google::protobuf::Map< ::google::protobuf::int64, ::std::string > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.value().data(), parser.value().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.Int64ToStringMap.MapEntry.value"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_map;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64ToStringMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64ToStringMap)
  return false;
#undef DO_
}

void Int64ToStringMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64ToStringMap)
  // map<int64, string> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_pointer
        ConstPtr;
    typedef ::google::protobuf::internal::SortItem< ::google::protobuf::int64, ConstPtr > SortItem;
    typedef ::google::protobuf::internal::CompareByFirstField<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->second.data(), p->second.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.Int64ToStringMap.MapEntry.value");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<Int64ToStringMap_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i].second->first, items[i].second->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i].second);
      }
    } else {
      ::google::protobuf::scoped_ptr<Int64ToStringMap_MapEntry> entry;
      for (::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64ToStringMap)
}

size_t Int64ToStringMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64ToStringMap)
  size_t total_size = 0;

  // map<int64, string> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<Int64ToStringMap_MapEntry> entry;
    for (::google::protobuf::Map< ::google::protobuf::int64, ::std::string >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64ToStringMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64ToStringMap*>(&from));
}

void Int64ToStringMap::MergeFrom(const Int64ToStringMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64ToStringMap)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Int64ToStringMap::UnsafeMergeFrom(const Int64ToStringMap& from) {
  GOOGLE_DCHECK(&from != this);
  map_.MergeFrom(from.map_);
}

void Int64ToStringMap::CopyFrom(const Int64ToStringMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64ToStringMap)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Int64ToStringMap::IsInitialized() const {

  return true;
}

void Int64ToStringMap::Swap(Int64ToStringMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64ToStringMap::InternalSwap(Int64ToStringMap* other) {
  map_.Swap(&other->map_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64ToStringMap::GetTypeName() const {
  return "CoreML.Specification.Int64ToStringMap";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64ToStringMap

// map<int64, string> map = 1;
int Int64ToStringMap::map_size() const {
  return map_.size();
}
void Int64ToStringMap::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >&
Int64ToStringMap::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Int64ToStringMap.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::google::protobuf::int64, ::std::string >*
Int64ToStringMap::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Int64ToStringMap.map)
  return map_.MutableMap();
}

inline const Int64ToStringMap* Int64ToStringMap::internal_default_instance() {
  return &Int64ToStringMap_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringToDoubleMap::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringToDoubleMap::StringToDoubleMap()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringToDoubleMap)
}

void StringToDoubleMap::InitAsDefaultInstance() {
}

StringToDoubleMap::StringToDoubleMap(const StringToDoubleMap& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringToDoubleMap)
}

void StringToDoubleMap::SharedCtor() {
  _cached_size_ = 0;
}

StringToDoubleMap::~StringToDoubleMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringToDoubleMap)
  SharedDtor();
}

void StringToDoubleMap::SharedDtor() {
}

void StringToDoubleMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringToDoubleMap& StringToDoubleMap::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<StringToDoubleMap> StringToDoubleMap_default_instance_;

StringToDoubleMap* StringToDoubleMap::New(::google::protobuf::Arena* arena) const {
  StringToDoubleMap* n = new StringToDoubleMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringToDoubleMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringToDoubleMap)
  map_.Clear();
}

bool StringToDoubleMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringToDoubleMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, double> map = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_map:
          StringToDoubleMap_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              ::std::string, double,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
              0 >,
            ::google::protobuf::Map< ::std::string, double > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.StringToDoubleMap.MapEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_map;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringToDoubleMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringToDoubleMap)
  return false;
#undef DO_
}

void StringToDoubleMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringToDoubleMap)
  // map<string, double> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::std::string, double >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "CoreML.Specification.StringToDoubleMap.MapEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::std::string, double >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<StringToDoubleMap_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<StringToDoubleMap_MapEntry> entry;
      for (::google::protobuf::Map< ::std::string, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringToDoubleMap)
}

size_t StringToDoubleMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringToDoubleMap)
  size_t total_size = 0;

  // map<string, double> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<StringToDoubleMap_MapEntry> entry;
    for (::google::protobuf::Map< ::std::string, double >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringToDoubleMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringToDoubleMap*>(&from));
}

void StringToDoubleMap::MergeFrom(const StringToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringToDoubleMap)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void StringToDoubleMap::UnsafeMergeFrom(const StringToDoubleMap& from) {
  GOOGLE_DCHECK(&from != this);
  map_.MergeFrom(from.map_);
}

void StringToDoubleMap::CopyFrom(const StringToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringToDoubleMap)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool StringToDoubleMap::IsInitialized() const {

  return true;
}

void StringToDoubleMap::Swap(StringToDoubleMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringToDoubleMap::InternalSwap(StringToDoubleMap* other) {
  map_.Swap(&other->map_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringToDoubleMap::GetTypeName() const {
  return "CoreML.Specification.StringToDoubleMap";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringToDoubleMap

// map<string, double> map = 1;
int StringToDoubleMap::map_size() const {
  return map_.size();
}
void StringToDoubleMap::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::std::string, double >&
StringToDoubleMap::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.StringToDoubleMap.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::std::string, double >*
StringToDoubleMap::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.StringToDoubleMap.map)
  return map_.MutableMap();
}

inline const StringToDoubleMap* StringToDoubleMap::internal_default_instance() {
  return &StringToDoubleMap_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64ToDoubleMap::kMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64ToDoubleMap::Int64ToDoubleMap()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64ToDoubleMap)
}

void Int64ToDoubleMap::InitAsDefaultInstance() {
}

Int64ToDoubleMap::Int64ToDoubleMap(const Int64ToDoubleMap& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64ToDoubleMap)
}

void Int64ToDoubleMap::SharedCtor() {
  _cached_size_ = 0;
}

Int64ToDoubleMap::~Int64ToDoubleMap() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64ToDoubleMap)
  SharedDtor();
}

void Int64ToDoubleMap::SharedDtor() {
}

void Int64ToDoubleMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64ToDoubleMap& Int64ToDoubleMap::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Int64ToDoubleMap> Int64ToDoubleMap_default_instance_;

Int64ToDoubleMap* Int64ToDoubleMap::New(::google::protobuf::Arena* arena) const {
  Int64ToDoubleMap* n = new Int64ToDoubleMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64ToDoubleMap::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64ToDoubleMap)
  map_.Clear();
}

bool Int64ToDoubleMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64ToDoubleMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<int64, double> map = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_map:
          Int64ToDoubleMap_MapEntry::Parser< ::google::protobuf::internal::MapFieldLite<
              ::google::protobuf::int64, double,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
              ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE,
              0 >,
            ::google::protobuf::Map< ::google::protobuf::int64, double > > parser(&map_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_map;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64ToDoubleMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64ToDoubleMap)
  return false;
#undef DO_
}

void Int64ToDoubleMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64ToDoubleMap)
  // map<int64, double> map = 1;
  if (!this->map().empty()) {
    typedef ::google::protobuf::Map< ::google::protobuf::int64, double >::const_pointer
        ConstPtr;
    typedef ::google::protobuf::internal::SortItem< ::google::protobuf::int64, ConstPtr > SortItem;
    typedef ::google::protobuf::internal::CompareByFirstField<SortItem> Less;

    if (output->IsSerializationDeterminstic() &&
        this->map().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->map().size()]);
      typedef ::google::protobuf::Map< ::google::protobuf::int64, double >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::google::protobuf::int64, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<Int64ToDoubleMap_MapEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(map_.NewEntryWrapper(
            items[i].second->first, items[i].second->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
      }
    } else {
      ::google::protobuf::scoped_ptr<Int64ToDoubleMap_MapEntry> entry;
      for (::google::protobuf::Map< ::google::protobuf::int64, double >::const_iterator
          it = this->map().begin();
          it != this->map().end(); ++it) {
        entry.reset(map_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessage(
            1, *entry, output);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64ToDoubleMap)
}

size_t Int64ToDoubleMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64ToDoubleMap)
  size_t total_size = 0;

  // map<int64, double> map = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->map_size());
  {
    ::google::protobuf::scoped_ptr<Int64ToDoubleMap_MapEntry> entry;
    for (::google::protobuf::Map< ::google::protobuf::int64, double >::const_iterator
        it = this->map().begin();
        it != this->map().end(); ++it) {
      entry.reset(map_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64ToDoubleMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64ToDoubleMap*>(&from));
}

void Int64ToDoubleMap::MergeFrom(const Int64ToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64ToDoubleMap)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Int64ToDoubleMap::UnsafeMergeFrom(const Int64ToDoubleMap& from) {
  GOOGLE_DCHECK(&from != this);
  map_.MergeFrom(from.map_);
}

void Int64ToDoubleMap::CopyFrom(const Int64ToDoubleMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64ToDoubleMap)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Int64ToDoubleMap::IsInitialized() const {

  return true;
}

void Int64ToDoubleMap::Swap(Int64ToDoubleMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64ToDoubleMap::InternalSwap(Int64ToDoubleMap* other) {
  map_.Swap(&other->map_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64ToDoubleMap::GetTypeName() const {
  return "CoreML.Specification.Int64ToDoubleMap";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64ToDoubleMap

// map<int64, double> map = 1;
int Int64ToDoubleMap::map_size() const {
  return map_.size();
}
void Int64ToDoubleMap::clear_map() {
  map_.Clear();
}
 const ::google::protobuf::Map< ::google::protobuf::int64, double >&
Int64ToDoubleMap::map() const {
  // @@protoc_insertion_point(field_map:CoreML.Specification.Int64ToDoubleMap.map)
  return map_.GetMap();
}
 ::google::protobuf::Map< ::google::protobuf::int64, double >*
Int64ToDoubleMap::mutable_map() {
  // @@protoc_insertion_point(field_mutable_map:CoreML.Specification.Int64ToDoubleMap.map)
  return map_.MutableMap();
}

inline const Int64ToDoubleMap* Int64ToDoubleMap::internal_default_instance() {
  return &Int64ToDoubleMap_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StringVector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StringVector::StringVector()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.StringVector)
}

void StringVector::InitAsDefaultInstance() {
}

StringVector::StringVector(const StringVector& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.StringVector)
}

void StringVector::SharedCtor() {
  _cached_size_ = 0;
}

StringVector::~StringVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.StringVector)
  SharedDtor();
}

void StringVector::SharedDtor() {
}

void StringVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StringVector& StringVector::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<StringVector> StringVector_default_instance_;

StringVector* StringVector::New(::google::protobuf::Arena* arena) const {
  StringVector* n = new StringVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StringVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.StringVector)
  vector_.Clear();
}

bool StringVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.StringVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string vector = 1;
      case 1: {
        if (tag == 10) {
         parse_vector:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_vector()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vector(this->vector_size() - 1).data(),
            this->vector(this->vector_size() - 1).length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "CoreML.Specification.StringVector.vector"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_vector;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.StringVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.StringVector)
  return false;
#undef DO_
}

void StringVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.StringVector)
  // repeated string vector = 1;
  for (int i = 0; i < this->vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vector(i).data(), this->vector(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "CoreML.Specification.StringVector.vector");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->vector(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.StringVector)
}

size_t StringVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.StringVector)
  size_t total_size = 0;

  // repeated string vector = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->vector_size());
  for (int i = 0; i < this->vector_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->vector(i));
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StringVector*>(&from));
}

void StringVector::MergeFrom(const StringVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.StringVector)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void StringVector::UnsafeMergeFrom(const StringVector& from) {
  GOOGLE_DCHECK(&from != this);
  vector_.UnsafeMergeFrom(from.vector_);
}

void StringVector::CopyFrom(const StringVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.StringVector)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool StringVector::IsInitialized() const {

  return true;
}

void StringVector::Swap(StringVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StringVector::InternalSwap(StringVector* other) {
  vector_.UnsafeArenaSwap(&other->vector_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StringVector::GetTypeName() const {
  return "CoreML.Specification.StringVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StringVector

// repeated string vector = 1;
int StringVector::vector_size() const {
  return vector_.size();
}
void StringVector::clear_vector() {
  vector_.Clear();
}
const ::std::string& StringVector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.StringVector.vector)
  return vector_.Get(index);
}
::std::string* StringVector::mutable_vector(int index) {
  // @@protoc_insertion_point(field_mutable:CoreML.Specification.StringVector.vector)
  return vector_.Mutable(index);
}
void StringVector::set_vector(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:CoreML.Specification.StringVector.vector)
  vector_.Mutable(index)->assign(value);
}
void StringVector::set_vector(int index, const char* value) {
  vector_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CoreML.Specification.StringVector.vector)
}
void StringVector::set_vector(int index, const char* value, size_t size) {
  vector_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CoreML.Specification.StringVector.vector)
}
::std::string* StringVector::add_vector() {
  // @@protoc_insertion_point(field_add_mutable:CoreML.Specification.StringVector.vector)
  return vector_.Add();
}
void StringVector::add_vector(const ::std::string& value) {
  vector_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.StringVector.vector)
}
void StringVector::add_vector(const char* value) {
  vector_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CoreML.Specification.StringVector.vector)
}
void StringVector::add_vector(const char* value, size_t size) {
  vector_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CoreML.Specification.StringVector.vector)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringVector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.StringVector.vector)
  return vector_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
StringVector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.StringVector.vector)
  return &vector_;
}

inline const StringVector* StringVector::internal_default_instance() {
  return &StringVector_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Int64Vector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Int64Vector::Int64Vector()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.Int64Vector)
}

void Int64Vector::InitAsDefaultInstance() {
}

Int64Vector::Int64Vector(const Int64Vector& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.Int64Vector)
}

void Int64Vector::SharedCtor() {
  _cached_size_ = 0;
}

Int64Vector::~Int64Vector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.Int64Vector)
  SharedDtor();
}

void Int64Vector::SharedDtor() {
}

void Int64Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Int64Vector& Int64Vector::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Int64Vector> Int64Vector_default_instance_;

Int64Vector* Int64Vector::New(::google::protobuf::Arena* arena) const {
  Int64Vector* n = new Int64Vector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Int64Vector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.Int64Vector)
  vector_.Clear();
}

bool Int64Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.Int64Vector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 vector = 1;
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_vector())));
        } else if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 10, input, this->mutable_vector())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.Int64Vector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.Int64Vector)
  return false;
#undef DO_
}

void Int64Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.Int64Vector)
  // repeated int64 vector = 1;
  if (this->vector_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_vector_cached_byte_size_);
  }
  for (int i = 0; i < this->vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64NoTag(
      this->vector(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.Int64Vector)
}

size_t Int64Vector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.Int64Vector)
  size_t total_size = 0;

  // repeated int64 vector = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->vector_size();
    for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->vector(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _vector_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Int64Vector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Int64Vector*>(&from));
}

void Int64Vector::MergeFrom(const Int64Vector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.Int64Vector)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Int64Vector::UnsafeMergeFrom(const Int64Vector& from) {
  GOOGLE_DCHECK(&from != this);
  vector_.UnsafeMergeFrom(from.vector_);
}

void Int64Vector::CopyFrom(const Int64Vector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.Int64Vector)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Int64Vector::IsInitialized() const {

  return true;
}

void Int64Vector::Swap(Int64Vector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Int64Vector::InternalSwap(Int64Vector* other) {
  vector_.UnsafeArenaSwap(&other->vector_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Int64Vector::GetTypeName() const {
  return "CoreML.Specification.Int64Vector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Int64Vector

// repeated int64 vector = 1;
int Int64Vector::vector_size() const {
  return vector_.size();
}
void Int64Vector::clear_vector() {
  vector_.Clear();
}
::google::protobuf::int64 Int64Vector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.Int64Vector.vector)
  return vector_.Get(index);
}
void Int64Vector::set_vector(int index, ::google::protobuf::int64 value) {
  vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.Int64Vector.vector)
}
void Int64Vector::add_vector(::google::protobuf::int64 value) {
  vector_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.Int64Vector.vector)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Int64Vector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.Int64Vector.vector)
  return vector_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Int64Vector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.Int64Vector.vector)
  return &vector_;
}

inline const Int64Vector* Int64Vector::internal_default_instance() {
  return &Int64Vector_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DoubleVector::kVectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DoubleVector::DoubleVector()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_DataStructures_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CoreML.Specification.DoubleVector)
}

void DoubleVector::InitAsDefaultInstance() {
}

DoubleVector::DoubleVector(const DoubleVector& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CoreML.Specification.DoubleVector)
}

void DoubleVector::SharedCtor() {
  _cached_size_ = 0;
}

DoubleVector::~DoubleVector() {
  // @@protoc_insertion_point(destructor:CoreML.Specification.DoubleVector)
  SharedDtor();
}

void DoubleVector::SharedDtor() {
}

void DoubleVector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DoubleVector& DoubleVector::default_instance() {
  protobuf_InitDefaults_DataStructures_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<DoubleVector> DoubleVector_default_instance_;

DoubleVector* DoubleVector::New(::google::protobuf::Arena* arena) const {
  DoubleVector* n = new DoubleVector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DoubleVector::Clear() {
// @@protoc_insertion_point(message_clear_start:CoreML.Specification.DoubleVector)
  vector_.Clear();
}

bool DoubleVector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CoreML.Specification.DoubleVector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated double vector = 1;
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_vector())));
        } else if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 10, input, this->mutable_vector())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CoreML.Specification.DoubleVector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CoreML.Specification.DoubleVector)
  return false;
#undef DO_
}

void DoubleVector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CoreML.Specification.DoubleVector)
  // repeated double vector = 1;
  if (this->vector_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_vector_cached_byte_size_);
  }
  for (int i = 0; i < this->vector_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDoubleNoTag(
      this->vector(i), output);
  }

  // @@protoc_insertion_point(serialize_end:CoreML.Specification.DoubleVector)
}

size_t DoubleVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CoreML.Specification.DoubleVector)
  size_t total_size = 0;

  // repeated double vector = 1;
  {
    size_t data_size = 0;
    unsigned int count = this->vector_size();
    data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _vector_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DoubleVector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DoubleVector*>(&from));
}

void DoubleVector::MergeFrom(const DoubleVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CoreML.Specification.DoubleVector)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void DoubleVector::UnsafeMergeFrom(const DoubleVector& from) {
  GOOGLE_DCHECK(&from != this);
  vector_.UnsafeMergeFrom(from.vector_);
}

void DoubleVector::CopyFrom(const DoubleVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CoreML.Specification.DoubleVector)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool DoubleVector::IsInitialized() const {

  return true;
}

void DoubleVector::Swap(DoubleVector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DoubleVector::InternalSwap(DoubleVector* other) {
  vector_.UnsafeArenaSwap(&other->vector_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DoubleVector::GetTypeName() const {
  return "CoreML.Specification.DoubleVector";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DoubleVector

// repeated double vector = 1;
int DoubleVector::vector_size() const {
  return vector_.size();
}
void DoubleVector::clear_vector() {
  vector_.Clear();
}
double DoubleVector::vector(int index) const {
  // @@protoc_insertion_point(field_get:CoreML.Specification.DoubleVector.vector)
  return vector_.Get(index);
}
void DoubleVector::set_vector(int index, double value) {
  vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:CoreML.Specification.DoubleVector.vector)
}
void DoubleVector::add_vector(double value) {
  vector_.Add(value);
  // @@protoc_insertion_point(field_add:CoreML.Specification.DoubleVector.vector)
}
const ::google::protobuf::RepeatedField< double >&
DoubleVector::vector() const {
  // @@protoc_insertion_point(field_list:CoreML.Specification.DoubleVector.vector)
  return vector_;
}
::google::protobuf::RepeatedField< double >*
DoubleVector::mutable_vector() {
  // @@protoc_insertion_point(field_mutable_list:CoreML.Specification.DoubleVector.vector)
  return &vector_;
}

inline const DoubleVector* DoubleVector::internal_default_instance() {
  return &DoubleVector_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Specification
}  // namespace CoreML

// @@protoc_insertion_point(global_scope)
